// Package mangadex provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.4.1 DO NOT EDIT.
package mangadex

import (
	"bytes"
	"compress/gzip"
	"context"
	"encoding/base64"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"path"
	"strings"
	"time"

	"github.com/getkin/kin-openapi/openapi3"
	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetAtHomeServerChapterId request
	GetAtHomeServerChapterId(ctx context.Context, chapterId openapi_types.UUID, params *GetAtHomeServerChapterIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthCheck request
	GetAuthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthLoginWithBody request with any body
	PostAuthLoginWithBody(ctx context.Context, params *PostAuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthLogin(ctx context.Context, params *PostAuthLoginParams, body PostAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthLogout request
	PostAuthLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthRefreshWithBody request with any body
	PostAuthRefreshWithBody(ctx context.Context, params *PostAuthRefreshParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthRefresh(ctx context.Context, params *PostAuthRefreshParams, body PostAuthRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthor request
	GetAuthor(ctx context.Context, params *GetAuthorParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostAuthorWithBody request with any body
	PostAuthorWithBody(ctx context.Context, params *PostAuthorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostAuthor(ctx context.Context, params *PostAuthorParams, body PostAuthorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteAuthorId request
	DeleteAuthorId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetAuthorId request
	GetAuthorId(ctx context.Context, id openapi_types.UUID, params *GetAuthorIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutAuthorIdWithBody request with any body
	PutAuthorIdWithBody(ctx context.Context, id openapi_types.UUID, params *PutAuthorIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutAuthorId(ctx context.Context, id openapi_types.UUID, params *PutAuthorIdParams, body PutAuthorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCaptchaSolveWithBody request with any body
	PostCaptchaSolveWithBody(ctx context.Context, params *PostCaptchaSolveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCaptchaSolve(ctx context.Context, params *PostCaptchaSolveParams, body PostCaptchaSolveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChapter request
	GetChapter(ctx context.Context, params *GetChapterParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteChapterId request
	DeleteChapterId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetChapterId request
	GetChapterId(ctx context.Context, id openapi_types.UUID, params *GetChapterIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutChapterIdWithBody request with any body
	PutChapterIdWithBody(ctx context.Context, id openapi_types.UUID, params *PutChapterIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutChapterId(ctx context.Context, id openapi_types.UUID, params *PutChapterIdParams, body PutChapterIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListApiclients request
	GetListApiclients(ctx context.Context, params *GetListApiclientsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostCreateApiclientWithBody request with any body
	PostCreateApiclientWithBody(ctx context.Context, params *PostCreateApiclientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostCreateApiclient(ctx context.Context, params *PostCreateApiclientParams, body PostCreateApiclientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteApiclient request
	DeleteApiclient(ctx context.Context, id openapi_types.UUID, params *DeleteApiclientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiclient request
	GetApiclient(ctx context.Context, id openapi_types.UUID, params *GetApiclientParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostEditApiclientWithBody request with any body
	PostEditApiclientWithBody(ctx context.Context, id openapi_types.UUID, params *PostEditApiclientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostEditApiclient(ctx context.Context, id openapi_types.UUID, params *PostEditApiclientParams, body PostEditApiclientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetApiclientSecret request
	GetApiclientSecret(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRegenerateApiclientSecretWithBody request with any body
	PostRegenerateApiclientSecretWithBody(ctx context.Context, id openapi_types.UUID, params *PostRegenerateApiclientSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRegenerateApiclientSecret(ctx context.Context, id openapi_types.UUID, params *PostRegenerateApiclientSecretParams, body PostRegenerateApiclientSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCover request
	GetCover(ctx context.Context, params *GetCoverParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteCover request
	DeleteCover(ctx context.Context, mangaOrCoverId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetCoverId request
	GetCoverId(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *GetCoverIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadCoverWithBody request with any body
	UploadCoverWithBody(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *UploadCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// EditCoverWithBody request with any body
	EditCoverWithBody(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *EditCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	EditCover(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *EditCoverParams, body EditCoverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// ForumsThreadCreateWithBody request with any body
	ForumsThreadCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	ForumsThreadCreate(ctx context.Context, body ForumsThreadCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchGroup request
	GetSearchGroup(ctx context.Context, params *GetSearchGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGroupWithBody request with any body
	PostGroupWithBody(ctx context.Context, params *PostGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostGroup(ctx context.Context, params *PostGroupParams, body PostGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupId request
	DeleteGroupId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetGroupId request
	GetGroupId(ctx context.Context, id openapi_types.UUID, params *GetGroupIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutGroupIdWithBody request with any body
	PutGroupIdWithBody(ctx context.Context, id openapi_types.UUID, params *PutGroupIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutGroupId(ctx context.Context, id openapi_types.UUID, params *PutGroupIdParams, body PutGroupIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteGroupIdFollow request
	DeleteGroupIdFollow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostGroupIdFollow request
	PostGroupIdFollow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLegacyMappingWithBody request with any body
	PostLegacyMappingWithBody(ctx context.Context, params *PostLegacyMappingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostLegacyMapping(ctx context.Context, params *PostLegacyMappingParams, body PostLegacyMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostListWithBody request with any body
	PostListWithBody(ctx context.Context, params *PostListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostList(ctx context.Context, params *PostListParams, body PostListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteListId request
	DeleteListId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListId request
	GetListId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutListIdWithBody request with any body
	PutListIdWithBody(ctx context.Context, id openapi_types.UUID, params *PutListIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutListId(ctx context.Context, id openapi_types.UUID, params *PutListIdParams, body PutListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetListIdFeed request
	GetListIdFeed(ctx context.Context, id openapi_types.UUID, params *GetListIdFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UnfollowListIdWithBody request with any body
	UnfollowListIdWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UnfollowListId(ctx context.Context, id openapi_types.UUID, body UnfollowListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// FollowListIdWithBody request with any body
	FollowListIdWithBody(ctx context.Context, id openapi_types.UUID, params *FollowListIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	FollowListId(ctx context.Context, id openapi_types.UUID, params *FollowListIdParams, body FollowListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSearchManga request
	GetSearchManga(ctx context.Context, params *GetSearchMangaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMangaWithBody request with any body
	PostMangaWithBody(ctx context.Context, params *PostMangaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostManga(ctx context.Context, params *PostMangaParams, body PostMangaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaDrafts request
	GetMangaDrafts(ctx context.Context, params *GetMangaDraftsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaIdDraft request
	GetMangaIdDraft(ctx context.Context, id openapi_types.UUID, params *GetMangaIdDraftParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitMangaDraftWithBody request with any body
	CommitMangaDraftWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommitMangaDraft(ctx context.Context, id openapi_types.UUID, body CommitMangaDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaRandom request
	GetMangaRandom(ctx context.Context, params *GetMangaRandomParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaChapterReadmarkers2 request
	GetMangaChapterReadmarkers2(ctx context.Context, params *GetMangaChapterReadmarkers2Params, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaStatus request
	GetMangaStatus(ctx context.Context, params *GetMangaStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaTag request
	GetMangaTag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMangaId request
	DeleteMangaId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaId request
	GetMangaId(ctx context.Context, id openapi_types.UUID, params *GetMangaIdParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutMangaIdWithBody request with any body
	PutMangaIdWithBody(ctx context.Context, id openapi_types.UUID, params *PutMangaIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutMangaId(ctx context.Context, id openapi_types.UUID, params *PutMangaIdParams, body PutMangaIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaAggregate request
	GetMangaAggregate(ctx context.Context, id openapi_types.UUID, params *GetMangaAggregateParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaIdFeed request
	GetMangaIdFeed(ctx context.Context, id openapi_types.UUID, params *GetMangaIdFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMangaIdFollow request
	DeleteMangaIdFollow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMangaIdFollow request
	PostMangaIdFollow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMangaIdListListId request
	DeleteMangaIdListListId(ctx context.Context, id openapi_types.UUID, listId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMangaIdListListId request
	PostMangaIdListListId(ctx context.Context, id openapi_types.UUID, listId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaChapterReadmarkers request
	GetMangaChapterReadmarkers(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMangaChapterReadmarkersWithBody request with any body
	PostMangaChapterReadmarkersWithBody(ctx context.Context, id openapi_types.UUID, params *PostMangaChapterReadmarkersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMangaChapterReadmarkers(ctx context.Context, id openapi_types.UUID, params *PostMangaChapterReadmarkersParams, body PostMangaChapterReadmarkersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaIdStatus request
	GetMangaIdStatus(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMangaIdStatusWithBody request with any body
	PostMangaIdStatusWithBody(ctx context.Context, id openapi_types.UUID, params *PostMangaIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMangaIdStatus(ctx context.Context, id openapi_types.UUID, params *PostMangaIdStatusParams, body PostMangaIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMangaRelation request
	GetMangaRelation(ctx context.Context, mangaId openapi_types.UUID, params *GetMangaRelationParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostMangaRelationWithBody request with any body
	PostMangaRelationWithBody(ctx context.Context, mangaId openapi_types.UUID, params *PostMangaRelationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostMangaRelation(ctx context.Context, mangaId openapi_types.UUID, params *PostMangaRelationParams, body PostMangaRelationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMangaRelationId request
	DeleteMangaRelationId(ctx context.Context, mangaId openapi_types.UUID, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPing request
	GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetRating request
	GetRating(ctx context.Context, params *GetRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRatingMangaId request
	DeleteRatingMangaId(ctx context.Context, mangaId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRatingMangaIdWithBody request with any body
	PostRatingMangaIdWithBody(ctx context.Context, mangaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostRatingMangaId(ctx context.Context, mangaId openapi_types.UUID, body PostRatingMangaIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReports request
	GetReports(ctx context.Context, params *GetReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostReportWithBody request with any body
	PostReportWithBody(ctx context.Context, params *PostReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostReport(ctx context.Context, params *PostReportParams, body PostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReportReasonsByCategory request
	GetReportReasonsByCategory(ctx context.Context, category string, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettings request
	GetSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSettingsWithBody request with any body
	PostSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSettings(ctx context.Context, body PostSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettingsTemplate request
	GetSettingsTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSettingsTemplateWithBody request with any body
	PostSettingsTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostSettingsTemplate(ctx context.Context, body PostSettingsTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetSettingsTemplateVersion request
	GetSettingsTemplateVersion(ctx context.Context, version openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatisticsChapters request
	GetStatisticsChapters(ctx context.Context, params *GetStatisticsChaptersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatisticsChapterUuid request
	GetStatisticsChapterUuid(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatisticsGroups request
	GetStatisticsGroups(ctx context.Context, params *GetStatisticsGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatisticsGroupUuid request
	GetStatisticsGroupUuid(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatisticsManga request
	GetStatisticsManga(ctx context.Context, params *GetStatisticsMangaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetStatisticsMangaUuid request
	GetStatisticsMangaUuid(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUploadSession request
	GetUploadSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BeginUploadSessionWithBody request with any body
	BeginUploadSessionWithBody(ctx context.Context, params *BeginUploadSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BeginUploadSession(ctx context.Context, params *BeginUploadSessionParams, body BeginUploadSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// BeginEditSessionWithBody request with any body
	BeginEditSessionWithBody(ctx context.Context, chapterId openapi_types.UUID, params *BeginEditSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	BeginEditSession(ctx context.Context, chapterId openapi_types.UUID, params *BeginEditSessionParams, body BeginEditSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// UploadCheckApprovalRequiredWithBody request with any body
	UploadCheckApprovalRequiredWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	UploadCheckApprovalRequired(ctx context.Context, body UploadCheckApprovalRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// AbandonUploadSession request
	AbandonUploadSession(ctx context.Context, uploadSessionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutUploadSessionFileWithBody request with any body
	PutUploadSessionFileWithBody(ctx context.Context, uploadSessionId openapi_types.UUID, params *PutUploadSessionFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUploadedSessionFilesWithBody request with any body
	DeleteUploadedSessionFilesWithBody(ctx context.Context, uploadSessionId openapi_types.UUID, params *DeleteUploadedSessionFilesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	DeleteUploadedSessionFiles(ctx context.Context, uploadSessionId openapi_types.UUID, params *DeleteUploadedSessionFilesParams, body DeleteUploadedSessionFilesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// CommitUploadSessionWithBody request with any body
	CommitUploadSessionWithBody(ctx context.Context, uploadSessionId openapi_types.UUID, params *CommitUploadSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	CommitUploadSession(ctx context.Context, uploadSessionId openapi_types.UUID, params *CommitUploadSessionParams, body CommitUploadSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUploadedSessionFile request
	DeleteUploadedSessionFile(ctx context.Context, uploadSessionId openapi_types.UUID, uploadSessionFileId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUser request
	GetUser(ctx context.Context, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostUserDeleteCode request
	PostUserDeleteCode(ctx context.Context, code openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFollowsGroup request
	GetUserFollowsGroup(ctx context.Context, params *GetUserFollowsGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFollowsGroupId request
	GetUserFollowsGroupId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFollowsList request
	GetUserFollowsList(ctx context.Context, params *GetUserFollowsListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFollowsListId request
	GetUserFollowsListId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFollowsManga request
	GetUserFollowsManga(ctx context.Context, params *GetUserFollowsMangaParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFollowsMangaFeed request
	GetUserFollowsMangaFeed(ctx context.Context, params *GetUserFollowsMangaFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFollowsMangaId request
	GetUserFollowsMangaId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFollowsUser request
	GetUserFollowsUser(ctx context.Context, params *GetUserFollowsUserParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserFollowsUserId request
	GetUserFollowsUserId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetReadingHistory request
	GetReadingHistory(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserList request
	GetUserList(ctx context.Context, params *GetUserListParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserMe request
	GetUserMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteUserId request
	DeleteUserId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserId request
	GetUserId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUserIdList request
	GetUserIdList(ctx context.Context, id openapi_types.UUID, params *GetUserIdListParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetAtHomeServerChapterId(ctx context.Context, chapterId openapi_types.UUID, params *GetAtHomeServerChapterIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAtHomeServerChapterIdRequest(c.Server, chapterId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthCheck(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthCheckRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthLoginWithBody(ctx context.Context, params *PostAuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthLoginRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthLogin(ctx context.Context, params *PostAuthLoginParams, body PostAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthLoginRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthLogout(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthLogoutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthRefreshWithBody(ctx context.Context, params *PostAuthRefreshParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRefreshRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthRefresh(ctx context.Context, params *PostAuthRefreshParams, body PostAuthRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthRefreshRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthor(ctx context.Context, params *GetAuthorParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthorWithBody(ctx context.Context, params *PostAuthorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostAuthor(ctx context.Context, params *PostAuthorParams, body PostAuthorJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostAuthorRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteAuthorId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteAuthorIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetAuthorId(ctx context.Context, id openapi_types.UUID, params *GetAuthorIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetAuthorIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAuthorIdWithBody(ctx context.Context, id openapi_types.UUID, params *PutAuthorIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAuthorIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutAuthorId(ctx context.Context, id openapi_types.UUID, params *PutAuthorIdParams, body PutAuthorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutAuthorIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCaptchaSolveWithBody(ctx context.Context, params *PostCaptchaSolveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCaptchaSolveRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCaptchaSolve(ctx context.Context, params *PostCaptchaSolveParams, body PostCaptchaSolveJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCaptchaSolveRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChapter(ctx context.Context, params *GetChapterParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChapterRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteChapterId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteChapterIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetChapterId(ctx context.Context, id openapi_types.UUID, params *GetChapterIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetChapterIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutChapterIdWithBody(ctx context.Context, id openapi_types.UUID, params *PutChapterIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutChapterIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutChapterId(ctx context.Context, id openapi_types.UUID, params *PutChapterIdParams, body PutChapterIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutChapterIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListApiclients(ctx context.Context, params *GetListApiclientsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListApiclientsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreateApiclientWithBody(ctx context.Context, params *PostCreateApiclientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateApiclientRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostCreateApiclient(ctx context.Context, params *PostCreateApiclientParams, body PostCreateApiclientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostCreateApiclientRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteApiclient(ctx context.Context, id openapi_types.UUID, params *DeleteApiclientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteApiclientRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiclient(ctx context.Context, id openapi_types.UUID, params *GetApiclientParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiclientRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditApiclientWithBody(ctx context.Context, id openapi_types.UUID, params *PostEditApiclientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditApiclientRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostEditApiclient(ctx context.Context, id openapi_types.UUID, params *PostEditApiclientParams, body PostEditApiclientJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostEditApiclientRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetApiclientSecret(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetApiclientSecretRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegenerateApiclientSecretWithBody(ctx context.Context, id openapi_types.UUID, params *PostRegenerateApiclientSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegenerateApiclientSecretRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRegenerateApiclientSecret(ctx context.Context, id openapi_types.UUID, params *PostRegenerateApiclientSecretParams, body PostRegenerateApiclientSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRegenerateApiclientSecretRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCover(ctx context.Context, params *GetCoverParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoverRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteCover(ctx context.Context, mangaOrCoverId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteCoverRequest(c.Server, mangaOrCoverId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetCoverId(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *GetCoverIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetCoverIdRequest(c.Server, mangaOrCoverId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCoverWithBody(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *UploadCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCoverRequestWithBody(c.Server, mangaOrCoverId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCoverWithBody(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *EditCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCoverRequestWithBody(c.Server, mangaOrCoverId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) EditCover(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *EditCoverParams, body EditCoverJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewEditCoverRequest(c.Server, mangaOrCoverId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForumsThreadCreateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForumsThreadCreateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) ForumsThreadCreate(ctx context.Context, body ForumsThreadCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewForumsThreadCreateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchGroup(ctx context.Context, params *GetSearchGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchGroupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGroupWithBody(ctx context.Context, params *PostGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGroupRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGroup(ctx context.Context, params *PostGroupParams, body PostGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGroupRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetGroupId(ctx context.Context, id openapi_types.UUID, params *GetGroupIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetGroupIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutGroupIdWithBody(ctx context.Context, id openapi_types.UUID, params *PutGroupIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutGroupIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutGroupId(ctx context.Context, id openapi_types.UUID, params *PutGroupIdParams, body PutGroupIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutGroupIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteGroupIdFollow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteGroupIdFollowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostGroupIdFollow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostGroupIdFollowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLegacyMappingWithBody(ctx context.Context, params *PostLegacyMappingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLegacyMappingRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLegacyMapping(ctx context.Context, params *PostLegacyMappingParams, body PostLegacyMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLegacyMappingRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostListWithBody(ctx context.Context, params *PostListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostListRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostList(ctx context.Context, params *PostListParams, body PostListJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostListRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteListId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteListIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutListIdWithBody(ctx context.Context, id openapi_types.UUID, params *PutListIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutListIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutListId(ctx context.Context, id openapi_types.UUID, params *PutListIdParams, body PutListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutListIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetListIdFeed(ctx context.Context, id openapi_types.UUID, params *GetListIdFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetListIdFeedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnfollowListIdWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnfollowListIdRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UnfollowListId(ctx context.Context, id openapi_types.UUID, body UnfollowListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUnfollowListIdRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FollowListIdWithBody(ctx context.Context, id openapi_types.UUID, params *FollowListIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowListIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) FollowListId(ctx context.Context, id openapi_types.UUID, params *FollowListIdParams, body FollowListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewFollowListIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSearchManga(ctx context.Context, params *GetSearchMangaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSearchMangaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMangaWithBody(ctx context.Context, params *PostMangaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMangaRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostManga(ctx context.Context, params *PostMangaParams, body PostMangaJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMangaRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaDrafts(ctx context.Context, params *GetMangaDraftsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaDraftsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaIdDraft(ctx context.Context, id openapi_types.UUID, params *GetMangaIdDraftParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaIdDraftRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitMangaDraftWithBody(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitMangaDraftRequestWithBody(c.Server, id, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitMangaDraft(ctx context.Context, id openapi_types.UUID, body CommitMangaDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitMangaDraftRequest(c.Server, id, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaRandom(ctx context.Context, params *GetMangaRandomParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaRandomRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaChapterReadmarkers2(ctx context.Context, params *GetMangaChapterReadmarkers2Params, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaChapterReadmarkers2Request(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaStatus(ctx context.Context, params *GetMangaStatusParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaStatusRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaTag(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaTagRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMangaId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMangaIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaId(ctx context.Context, id openapi_types.UUID, params *GetMangaIdParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaIdRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutMangaIdWithBody(ctx context.Context, id openapi_types.UUID, params *PutMangaIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutMangaIdRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutMangaId(ctx context.Context, id openapi_types.UUID, params *PutMangaIdParams, body PutMangaIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutMangaIdRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaAggregate(ctx context.Context, id openapi_types.UUID, params *GetMangaAggregateParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaAggregateRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaIdFeed(ctx context.Context, id openapi_types.UUID, params *GetMangaIdFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaIdFeedRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMangaIdFollow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMangaIdFollowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMangaIdFollow(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMangaIdFollowRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMangaIdListListId(ctx context.Context, id openapi_types.UUID, listId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMangaIdListListIdRequest(c.Server, id, listId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMangaIdListListId(ctx context.Context, id openapi_types.UUID, listId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMangaIdListListIdRequest(c.Server, id, listId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaChapterReadmarkers(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaChapterReadmarkersRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMangaChapterReadmarkersWithBody(ctx context.Context, id openapi_types.UUID, params *PostMangaChapterReadmarkersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMangaChapterReadmarkersRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMangaChapterReadmarkers(ctx context.Context, id openapi_types.UUID, params *PostMangaChapterReadmarkersParams, body PostMangaChapterReadmarkersJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMangaChapterReadmarkersRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaIdStatus(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaIdStatusRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMangaIdStatusWithBody(ctx context.Context, id openapi_types.UUID, params *PostMangaIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMangaIdStatusRequestWithBody(c.Server, id, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMangaIdStatus(ctx context.Context, id openapi_types.UUID, params *PostMangaIdStatusParams, body PostMangaIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMangaIdStatusRequest(c.Server, id, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMangaRelation(ctx context.Context, mangaId openapi_types.UUID, params *GetMangaRelationParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMangaRelationRequest(c.Server, mangaId, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMangaRelationWithBody(ctx context.Context, mangaId openapi_types.UUID, params *PostMangaRelationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMangaRelationRequestWithBody(c.Server, mangaId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostMangaRelation(ctx context.Context, mangaId openapi_types.UUID, params *PostMangaRelationParams, body PostMangaRelationJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostMangaRelationRequest(c.Server, mangaId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMangaRelationId(ctx context.Context, mangaId openapi_types.UUID, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMangaRelationIdRequest(c.Server, mangaId, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPing(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPingRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetRating(ctx context.Context, params *GetRatingParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetRatingRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRatingMangaId(ctx context.Context, mangaId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRatingMangaIdRequest(c.Server, mangaId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRatingMangaIdWithBody(ctx context.Context, mangaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRatingMangaIdRequestWithBody(c.Server, mangaId, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRatingMangaId(ctx context.Context, mangaId openapi_types.UUID, body PostRatingMangaIdJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRatingMangaIdRequest(c.Server, mangaId, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReports(ctx context.Context, params *GetReportsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReportWithBody(ctx context.Context, params *PostReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReportRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostReport(ctx context.Context, params *PostReportParams, body PostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostReportRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReportReasonsByCategory(ctx context.Context, category string, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReportReasonsByCategoryRequest(c.Server, category)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettings(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSettingsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSettingsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSettings(ctx context.Context, body PostSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSettingsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettingsTemplate(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsTemplateRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSettingsTemplateWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSettingsTemplateRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSettingsTemplate(ctx context.Context, body PostSettingsTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSettingsTemplateRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetSettingsTemplateVersion(ctx context.Context, version openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetSettingsTemplateVersionRequest(c.Server, version)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatisticsChapters(ctx context.Context, params *GetStatisticsChaptersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatisticsChaptersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatisticsChapterUuid(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatisticsChapterUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatisticsGroups(ctx context.Context, params *GetStatisticsGroupsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatisticsGroupsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatisticsGroupUuid(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatisticsGroupUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatisticsManga(ctx context.Context, params *GetStatisticsMangaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatisticsMangaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetStatisticsMangaUuid(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetStatisticsMangaUuidRequest(c.Server, uuid)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUploadSession(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUploadSessionRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BeginUploadSessionWithBody(ctx context.Context, params *BeginUploadSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBeginUploadSessionRequestWithBody(c.Server, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BeginUploadSession(ctx context.Context, params *BeginUploadSessionParams, body BeginUploadSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBeginUploadSessionRequest(c.Server, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BeginEditSessionWithBody(ctx context.Context, chapterId openapi_types.UUID, params *BeginEditSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBeginEditSessionRequestWithBody(c.Server, chapterId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) BeginEditSession(ctx context.Context, chapterId openapi_types.UUID, params *BeginEditSessionParams, body BeginEditSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewBeginEditSessionRequest(c.Server, chapterId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCheckApprovalRequiredWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCheckApprovalRequiredRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) UploadCheckApprovalRequired(ctx context.Context, body UploadCheckApprovalRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewUploadCheckApprovalRequiredRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) AbandonUploadSession(ctx context.Context, uploadSessionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewAbandonUploadSessionRequest(c.Server, uploadSessionId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutUploadSessionFileWithBody(ctx context.Context, uploadSessionId openapi_types.UUID, params *PutUploadSessionFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutUploadSessionFileRequestWithBody(c.Server, uploadSessionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUploadedSessionFilesWithBody(ctx context.Context, uploadSessionId openapi_types.UUID, params *DeleteUploadedSessionFilesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUploadedSessionFilesRequestWithBody(c.Server, uploadSessionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUploadedSessionFiles(ctx context.Context, uploadSessionId openapi_types.UUID, params *DeleteUploadedSessionFilesParams, body DeleteUploadedSessionFilesJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUploadedSessionFilesRequest(c.Server, uploadSessionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitUploadSessionWithBody(ctx context.Context, uploadSessionId openapi_types.UUID, params *CommitUploadSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitUploadSessionRequestWithBody(c.Server, uploadSessionId, params, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) CommitUploadSession(ctx context.Context, uploadSessionId openapi_types.UUID, params *CommitUploadSessionParams, body CommitUploadSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewCommitUploadSessionRequest(c.Server, uploadSessionId, params, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUploadedSessionFile(ctx context.Context, uploadSessionId openapi_types.UUID, uploadSessionFileId openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUploadedSessionFileRequest(c.Server, uploadSessionId, uploadSessionFileId)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUser(ctx context.Context, params *GetUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostUserDeleteCode(ctx context.Context, code openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostUserDeleteCodeRequest(c.Server, code)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFollowsGroup(ctx context.Context, params *GetUserFollowsGroupParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFollowsGroupRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFollowsGroupId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFollowsGroupIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFollowsList(ctx context.Context, params *GetUserFollowsListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFollowsListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFollowsListId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFollowsListIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFollowsManga(ctx context.Context, params *GetUserFollowsMangaParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFollowsMangaRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFollowsMangaFeed(ctx context.Context, params *GetUserFollowsMangaFeedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFollowsMangaFeedRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFollowsMangaId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFollowsMangaIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFollowsUser(ctx context.Context, params *GetUserFollowsUserParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFollowsUserRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserFollowsUserId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserFollowsUserIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetReadingHistory(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetReadingHistoryRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserList(ctx context.Context, params *GetUserListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserListRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteUserId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteUserIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserId(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserIdRequest(c.Server, id)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUserIdList(ctx context.Context, id openapi_types.UUID, params *GetUserIdListParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUserIdListRequest(c.Server, id, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetAtHomeServerChapterIdRequest generates requests for GetAtHomeServerChapterId
func NewGetAtHomeServerChapterIdRequest(server string, chapterId openapi_types.UUID, params *GetAtHomeServerChapterIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chapterId", runtime.ParamLocationPath, chapterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/at-home/server/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ForcePort443 != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "forcePort443", runtime.ParamLocationQuery, *params.ForcePort443); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthCheckRequest generates requests for GetAuthCheck
func NewGetAuthCheckRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/check")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthLoginRequest calls the generic PostAuthLogin builder with application/json body
func NewPostAuthLoginRequest(server string, params *PostAuthLoginParams, body PostAuthLoginJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthLoginRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthLoginRequestWithBody generates requests for PostAuthLogin with any type of body
func NewPostAuthLoginRequestWithBody(server string, params *PostAuthLoginParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/login")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewPostAuthLogoutRequest generates requests for PostAuthLogout
func NewPostAuthLogoutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/logout")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthRefreshRequest calls the generic PostAuthRefresh builder with application/json body
func NewPostAuthRefreshRequest(server string, params *PostAuthRefreshParams, body PostAuthRefreshJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthRefreshRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthRefreshRequestWithBody generates requests for PostAuthRefresh with any type of body
func NewPostAuthRefreshRequestWithBody(server string, params *PostAuthRefreshParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/auth/refresh")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetAuthorRequest generates requests for GetAuthor
func NewGetAuthorRequest(server string, params *GetAuthorParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/author")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids[]", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostAuthorRequest calls the generic PostAuthor builder with application/json body
func NewPostAuthorRequest(server string, params *PostAuthorParams, body PostAuthorJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostAuthorRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostAuthorRequestWithBody generates requests for PostAuthor with any type of body
func NewPostAuthorRequestWithBody(server string, params *PostAuthorParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/author")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewDeleteAuthorIdRequest generates requests for DeleteAuthorId
func NewDeleteAuthorIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/author/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetAuthorIdRequest generates requests for GetAuthorId
func NewGetAuthorIdRequest(server string, id openapi_types.UUID, params *GetAuthorIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/author/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutAuthorIdRequest calls the generic PutAuthorId builder with application/json body
func NewPutAuthorIdRequest(server string, id openapi_types.UUID, params *PutAuthorIdParams, body PutAuthorIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutAuthorIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPutAuthorIdRequestWithBody generates requests for PutAuthorId with any type of body
func NewPutAuthorIdRequestWithBody(server string, id openapi_types.UUID, params *PutAuthorIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/author/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewPostCaptchaSolveRequest calls the generic PostCaptchaSolve builder with application/json body
func NewPostCaptchaSolveRequest(server string, params *PostCaptchaSolveParams, body PostCaptchaSolveJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCaptchaSolveRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCaptchaSolveRequestWithBody generates requests for PostCaptchaSolve with any type of body
func NewPostCaptchaSolveRequestWithBody(server string, params *PostCaptchaSolveParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/captcha/solve")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetChapterRequest generates requests for GetChapter
func NewGetChapterRequest(server string, params *GetChapterParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chapter")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids[]", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Groups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groups[]", runtime.ParamLocationQuery, *params.Groups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uploader != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uploader", runtime.ParamLocationQuery, *params.Uploader); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Manga != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "manga", runtime.ParamLocationQuery, *params.Manga); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Volume != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "volume[]", runtime.ParamLocationQuery, *params.Volume); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Chapter != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "chapter", runtime.ParamLocationQuery, *params.Chapter); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranslatedLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "translatedLanguage[]", runtime.ParamLocationQuery, *params.TranslatedLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originalLanguage[]", runtime.ParamLocationQuery, *params.OriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedOriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedOriginalLanguage[]", runtime.ParamLocationQuery, *params.ExcludedOriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentRating[]", runtime.ParamLocationQuery, *params.ContentRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedGroups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedGroups[]", runtime.ParamLocationQuery, *params.ExcludedGroups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedUploaders != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedUploaders[]", runtime.ParamLocationQuery, *params.ExcludedUploaders); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFutureUpdates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFutureUpdates", runtime.ParamLocationQuery, *params.IncludeFutureUpdates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeEmptyPages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeEmptyPages", runtime.ParamLocationQuery, *params.IncludeEmptyPages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFuturePublishAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFuturePublishAt", runtime.ParamLocationQuery, *params.IncludeFuturePublishAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeExternalUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeExternalUrl", runtime.ParamLocationQuery, *params.IncludeExternalUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUnavailable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeUnavailable", runtime.ParamLocationQuery, *params.IncludeUnavailable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAtSince", runtime.ParamLocationQuery, *params.CreatedAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedAtSince", runtime.ParamLocationQuery, *params.UpdatedAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publishAtSince", runtime.ParamLocationQuery, *params.PublishAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteChapterIdRequest generates requests for DeleteChapterId
func NewDeleteChapterIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chapter/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetChapterIdRequest generates requests for GetChapterId
func NewGetChapterIdRequest(server string, id openapi_types.UUID, params *GetChapterIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chapter/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutChapterIdRequest calls the generic PutChapterId builder with application/json body
func NewPutChapterIdRequest(server string, id openapi_types.UUID, params *PutChapterIdParams, body PutChapterIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutChapterIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPutChapterIdRequestWithBody generates requests for PutChapterId with any type of body
func NewPutChapterIdRequestWithBody(server string, id openapi_types.UUID, params *PutChapterIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/chapter/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetListApiclientsRequest generates requests for GetListApiclients
func NewGetListApiclientsRequest(server string, params *GetListApiclientsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/client")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostCreateApiclientRequest calls the generic PostCreateApiclient builder with application/json body
func NewPostCreateApiclientRequest(server string, params *PostCreateApiclientParams, body PostCreateApiclientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostCreateApiclientRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostCreateApiclientRequestWithBody generates requests for PostCreateApiclient with any type of body
func NewPostCreateApiclientRequestWithBody(server string, params *PostCreateApiclientParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/client")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewDeleteApiclientRequest generates requests for DeleteApiclient
func NewDeleteApiclientRequest(server string, id openapi_types.UUID, params *DeleteApiclientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/client/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Version != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "version", runtime.ParamLocationQuery, *params.Version); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetApiclientRequest generates requests for GetApiclient
func NewGetApiclientRequest(server string, id openapi_types.UUID, params *GetApiclientParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/client/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostEditApiclientRequest calls the generic PostEditApiclient builder with application/json body
func NewPostEditApiclientRequest(server string, id openapi_types.UUID, params *PostEditApiclientParams, body PostEditApiclientJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostEditApiclientRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostEditApiclientRequestWithBody generates requests for PostEditApiclient with any type of body
func NewPostEditApiclientRequestWithBody(server string, id openapi_types.UUID, params *PostEditApiclientParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/client/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetApiclientSecretRequest generates requests for GetApiclientSecret
func NewGetApiclientSecretRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/client/%s/secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRegenerateApiclientSecretRequest calls the generic PostRegenerateApiclientSecret builder with application/json body
func NewPostRegenerateApiclientSecretRequest(server string, id openapi_types.UUID, params *PostRegenerateApiclientSecretParams, body PostRegenerateApiclientSecretJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRegenerateApiclientSecretRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostRegenerateApiclientSecretRequestWithBody generates requests for PostRegenerateApiclientSecret with any type of body
func NewPostRegenerateApiclientSecretRequestWithBody(server string, id openapi_types.UUID, params *PostRegenerateApiclientSecretParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/client/%s/secret", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetCoverRequest generates requests for GetCover
func NewGetCoverRequest(server string, params *GetCoverParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cover")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Manga != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "manga[]", runtime.ParamLocationQuery, *params.Manga); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids[]", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Uploaders != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "uploaders[]", runtime.ParamLocationQuery, *params.Uploaders); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Locales != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "locales[]", runtime.ParamLocationQuery, *params.Locales); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteCoverRequest generates requests for DeleteCover
func NewDeleteCoverRequest(server string, mangaOrCoverId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mangaOrCoverId", runtime.ParamLocationPath, mangaOrCoverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cover/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetCoverIdRequest generates requests for GetCoverId
func NewGetCoverIdRequest(server string, mangaOrCoverId openapi_types.UUID, params *GetCoverIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mangaOrCoverId", runtime.ParamLocationPath, mangaOrCoverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cover/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUploadCoverRequestWithBody generates requests for UploadCover with any type of body
func NewUploadCoverRequestWithBody(server string, mangaOrCoverId openapi_types.UUID, params *UploadCoverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mangaOrCoverId", runtime.ParamLocationPath, mangaOrCoverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cover/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewEditCoverRequest calls the generic EditCover builder with application/json body
func NewEditCoverRequest(server string, mangaOrCoverId openapi_types.UUID, params *EditCoverParams, body EditCoverJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewEditCoverRequestWithBody(server, mangaOrCoverId, params, "application/json", bodyReader)
}

// NewEditCoverRequestWithBody generates requests for EditCover with any type of body
func NewEditCoverRequestWithBody(server string, mangaOrCoverId openapi_types.UUID, params *EditCoverParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mangaOrCoverId", runtime.ParamLocationPath, mangaOrCoverId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/cover/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewForumsThreadCreateRequest calls the generic ForumsThreadCreate builder with application/json body
func NewForumsThreadCreateRequest(server string, body ForumsThreadCreateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewForumsThreadCreateRequestWithBody(server, "application/json", bodyReader)
}

// NewForumsThreadCreateRequestWithBody generates requests for ForumsThreadCreate with any type of body
func NewForumsThreadCreateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/forums/thread")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSearchGroupRequest generates requests for GetSearchGroup
func NewGetSearchGroupRequest(server string, params *GetSearchGroupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids[]", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Name != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "name", runtime.ParamLocationQuery, *params.Name); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.FocusedLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "focusedLanguage", runtime.ParamLocationQuery, *params.FocusedLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostGroupRequest calls the generic PostGroup builder with application/json body
func NewPostGroupRequest(server string, params *PostGroupParams, body PostGroupJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostGroupRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostGroupRequestWithBody generates requests for PostGroup with any type of body
func NewPostGroupRequestWithBody(server string, params *PostGroupParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewDeleteGroupIdRequest generates requests for DeleteGroupId
func NewDeleteGroupIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetGroupIdRequest generates requests for GetGroupId
func NewGetGroupIdRequest(server string, id openapi_types.UUID, params *GetGroupIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutGroupIdRequest calls the generic PutGroupId builder with application/json body
func NewPutGroupIdRequest(server string, id openapi_types.UUID, params *PutGroupIdParams, body PutGroupIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutGroupIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPutGroupIdRequestWithBody generates requests for PutGroupId with any type of body
func NewPutGroupIdRequestWithBody(server string, id openapi_types.UUID, params *PutGroupIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewDeleteGroupIdFollowRequest generates requests for DeleteGroupIdFollow
func NewDeleteGroupIdFollowRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group/%s/follow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostGroupIdFollowRequest generates requests for PostGroupIdFollow
func NewPostGroupIdFollowRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/group/%s/follow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLegacyMappingRequest calls the generic PostLegacyMapping builder with application/json body
func NewPostLegacyMappingRequest(server string, params *PostLegacyMappingParams, body PostLegacyMappingJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostLegacyMappingRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostLegacyMappingRequestWithBody generates requests for PostLegacyMapping with any type of body
func NewPostLegacyMappingRequestWithBody(server string, params *PostLegacyMappingParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/legacy/mapping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewPostListRequest calls the generic PostList builder with application/json body
func NewPostListRequest(server string, params *PostListParams, body PostListJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostListRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostListRequestWithBody generates requests for PostList with any type of body
func NewPostListRequestWithBody(server string, params *PostListParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewDeleteListIdRequest generates requests for DeleteListId
func NewDeleteListIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetListIdRequest generates requests for GetListId
func NewGetListIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutListIdRequest calls the generic PutListId builder with application/json body
func NewPutListIdRequest(server string, id openapi_types.UUID, params *PutListIdParams, body PutListIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutListIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPutListIdRequestWithBody generates requests for PutListId with any type of body
func NewPutListIdRequestWithBody(server string, id openapi_types.UUID, params *PutListIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetListIdFeedRequest generates requests for GetListIdFeed
func NewGetListIdFeedRequest(server string, id openapi_types.UUID, params *GetListIdFeedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/list/%s/feed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranslatedLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "translatedLanguage[]", runtime.ParamLocationQuery, *params.TranslatedLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originalLanguage[]", runtime.ParamLocationQuery, *params.OriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedOriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedOriginalLanguage[]", runtime.ParamLocationQuery, *params.ExcludedOriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentRating[]", runtime.ParamLocationQuery, *params.ContentRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedGroups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedGroups[]", runtime.ParamLocationQuery, *params.ExcludedGroups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedUploaders != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedUploaders[]", runtime.ParamLocationQuery, *params.ExcludedUploaders); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFutureUpdates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFutureUpdates", runtime.ParamLocationQuery, *params.IncludeFutureUpdates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAtSince", runtime.ParamLocationQuery, *params.CreatedAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedAtSince", runtime.ParamLocationQuery, *params.UpdatedAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publishAtSince", runtime.ParamLocationQuery, *params.PublishAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeEmptyPages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeEmptyPages", runtime.ParamLocationQuery, *params.IncludeEmptyPages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFuturePublishAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFuturePublishAt", runtime.ParamLocationQuery, *params.IncludeFuturePublishAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeExternalUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeExternalUrl", runtime.ParamLocationQuery, *params.IncludeExternalUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUnavailable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeUnavailable", runtime.ParamLocationQuery, *params.IncludeUnavailable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewUnfollowListIdRequest calls the generic UnfollowListId builder with application/json body
func NewUnfollowListIdRequest(server string, id openapi_types.UUID, body UnfollowListIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUnfollowListIdRequestWithBody(server, id, "application/json", bodyReader)
}

// NewUnfollowListIdRequestWithBody generates requests for UnfollowListId with any type of body
func NewUnfollowListIdRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/list/%s/follow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewFollowListIdRequest calls the generic FollowListId builder with application/json body
func NewFollowListIdRequest(server string, id openapi_types.UUID, params *FollowListIdParams, body FollowListIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewFollowListIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewFollowListIdRequestWithBody generates requests for FollowListId with any type of body
func NewFollowListIdRequestWithBody(server string, id openapi_types.UUID, params *FollowListIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/list/%s/follow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetSearchMangaRequest generates requests for GetSearchManga
func NewGetSearchMangaRequest(server string, params *GetSearchMangaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Title != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "title", runtime.ParamLocationQuery, *params.Title); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AuthorOrArtist != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authorOrArtist", runtime.ParamLocationQuery, *params.AuthorOrArtist); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Authors != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "authors[]", runtime.ParamLocationQuery, *params.Authors); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Artists != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "artists[]", runtime.ParamLocationQuery, *params.Artists); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Year != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "year", runtime.ParamLocationQuery, *params.Year); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedTags[]", runtime.ParamLocationQuery, *params.IncludedTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedTagsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedTagsMode", runtime.ParamLocationQuery, *params.IncludedTagsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedTags[]", runtime.ParamLocationQuery, *params.ExcludedTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedTagsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedTagsMode", runtime.ParamLocationQuery, *params.ExcludedTagsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status[]", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originalLanguage[]", runtime.ParamLocationQuery, *params.OriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedOriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedOriginalLanguage[]", runtime.ParamLocationQuery, *params.ExcludedOriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.AvailableTranslatedLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "availableTranslatedLanguage[]", runtime.ParamLocationQuery, *params.AvailableTranslatedLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublicationDemographic != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publicationDemographic[]", runtime.ParamLocationQuery, *params.PublicationDemographic); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids[]", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentRating[]", runtime.ParamLocationQuery, *params.ContentRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAtSince", runtime.ParamLocationQuery, *params.CreatedAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedAtSince", runtime.ParamLocationQuery, *params.UpdatedAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasAvailableChapters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasAvailableChapters", runtime.ParamLocationQuery, *params.HasAvailableChapters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.HasUnavailableChapters != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "hasUnavailableChapters", runtime.ParamLocationQuery, *params.HasUnavailableChapters); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Group != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "group", runtime.ParamLocationQuery, *params.Group); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMangaRequest calls the generic PostManga builder with application/json body
func NewPostMangaRequest(server string, params *PostMangaParams, body PostMangaJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMangaRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostMangaRequestWithBody generates requests for PostManga with any type of body
func NewPostMangaRequestWithBody(server string, params *PostMangaParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetMangaDraftsRequest generates requests for GetMangaDrafts
func NewGetMangaDraftsRequest(server string, params *GetMangaDraftsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/draft")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaIdDraftRequest generates requests for GetMangaIdDraft
func NewGetMangaIdDraftRequest(server string, id openapi_types.UUID, params *GetMangaIdDraftParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/draft/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewCommitMangaDraftRequest calls the generic CommitMangaDraft builder with application/json body
func NewCommitMangaDraftRequest(server string, id openapi_types.UUID, body CommitMangaDraftJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitMangaDraftRequestWithBody(server, id, "application/json", bodyReader)
}

// NewCommitMangaDraftRequestWithBody generates requests for CommitMangaDraft with any type of body
func NewCommitMangaDraftRequestWithBody(server string, id openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/draft/%s/commit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMangaRandomRequest generates requests for GetMangaRandom
func NewGetMangaRandomRequest(server string, params *GetMangaRandomParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/random")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentRating[]", runtime.ParamLocationQuery, *params.ContentRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedTags[]", runtime.ParamLocationQuery, *params.IncludedTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludedTagsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includedTagsMode", runtime.ParamLocationQuery, *params.IncludedTagsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedTags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedTags[]", runtime.ParamLocationQuery, *params.ExcludedTags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedTagsMode != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedTagsMode", runtime.ParamLocationQuery, *params.ExcludedTagsMode); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaChapterReadmarkers2Request generates requests for GetMangaChapterReadmarkers2
func NewGetMangaChapterReadmarkers2Request(server string, params *GetMangaChapterReadmarkers2Params) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/read")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids[]", runtime.ParamLocationQuery, params.Ids); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.Grouped != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "grouped", runtime.ParamLocationQuery, *params.Grouped); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaStatusRequest generates requests for GetMangaStatus
func NewGetMangaStatusRequest(server string, params *GetMangaStatusParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/status")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaTagRequest generates requests for GetMangaTag
func NewGetMangaTagRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/tag")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMangaIdRequest generates requests for DeleteMangaId
func NewDeleteMangaIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaIdRequest generates requests for GetMangaId
func NewGetMangaIdRequest(server string, id openapi_types.UUID, params *GetMangaIdParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutMangaIdRequest calls the generic PutMangaId builder with application/json body
func NewPutMangaIdRequest(server string, id openapi_types.UUID, params *PutMangaIdParams, body PutMangaIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutMangaIdRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPutMangaIdRequestWithBody generates requests for PutMangaId with any type of body
func NewPutMangaIdRequestWithBody(server string, id openapi_types.UUID, params *PutMangaIdParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetMangaAggregateRequest generates requests for GetMangaAggregate
func NewGetMangaAggregateRequest(server string, id openapi_types.UUID, params *GetMangaAggregateParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/aggregate", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.TranslatedLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "translatedLanguage[]", runtime.ParamLocationQuery, *params.TranslatedLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Groups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "groups[]", runtime.ParamLocationQuery, *params.Groups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaIdFeedRequest generates requests for GetMangaIdFeed
func NewGetMangaIdFeedRequest(server string, id openapi_types.UUID, params *GetMangaIdFeedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/feed", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranslatedLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "translatedLanguage[]", runtime.ParamLocationQuery, *params.TranslatedLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originalLanguage[]", runtime.ParamLocationQuery, *params.OriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedOriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedOriginalLanguage[]", runtime.ParamLocationQuery, *params.ExcludedOriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentRating[]", runtime.ParamLocationQuery, *params.ContentRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedGroups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedGroups[]", runtime.ParamLocationQuery, *params.ExcludedGroups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedUploaders != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedUploaders[]", runtime.ParamLocationQuery, *params.ExcludedUploaders); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFutureUpdates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFutureUpdates", runtime.ParamLocationQuery, *params.IncludeFutureUpdates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAtSince", runtime.ParamLocationQuery, *params.CreatedAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedAtSince", runtime.ParamLocationQuery, *params.UpdatedAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publishAtSince", runtime.ParamLocationQuery, *params.PublishAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeEmptyPages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeEmptyPages", runtime.ParamLocationQuery, *params.IncludeEmptyPages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFuturePublishAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFuturePublishAt", runtime.ParamLocationQuery, *params.IncludeFuturePublishAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeExternalUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeExternalUrl", runtime.ParamLocationQuery, *params.IncludeExternalUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUnavailable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeUnavailable", runtime.ParamLocationQuery, *params.IncludeUnavailable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMangaIdFollowRequest generates requests for DeleteMangaIdFollow
func NewDeleteMangaIdFollowRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/follow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMangaIdFollowRequest generates requests for PostMangaIdFollow
func NewPostMangaIdFollowRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/follow", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMangaIdListListIdRequest generates requests for DeleteMangaIdListListId
func NewDeleteMangaIdListListIdRequest(server string, id openapi_types.UUID, listId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "listId", runtime.ParamLocationPath, listId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/list/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMangaIdListListIdRequest generates requests for PostMangaIdListListId
func NewPostMangaIdListListIdRequest(server string, id openapi_types.UUID, listId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "listId", runtime.ParamLocationPath, listId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/list/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMangaChapterReadmarkersRequest generates requests for GetMangaChapterReadmarkers
func NewGetMangaChapterReadmarkersRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/read", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMangaChapterReadmarkersRequest calls the generic PostMangaChapterReadmarkers builder with application/json body
func NewPostMangaChapterReadmarkersRequest(server string, id openapi_types.UUID, params *PostMangaChapterReadmarkersParams, body PostMangaChapterReadmarkersJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMangaChapterReadmarkersRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostMangaChapterReadmarkersRequestWithBody generates requests for PostMangaChapterReadmarkers with any type of body
func NewPostMangaChapterReadmarkersRequestWithBody(server string, id openapi_types.UUID, params *PostMangaChapterReadmarkersParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/read", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.UpdateHistory != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updateHistory", runtime.ParamLocationQuery, *params.UpdateHistory); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetMangaIdStatusRequest generates requests for GetMangaIdStatus
func NewGetMangaIdStatusRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMangaIdStatusRequest calls the generic PostMangaIdStatus builder with application/json body
func NewPostMangaIdStatusRequest(server string, id openapi_types.UUID, params *PostMangaIdStatusParams, body PostMangaIdStatusJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMangaIdStatusRequestWithBody(server, id, params, "application/json", bodyReader)
}

// NewPostMangaIdStatusRequestWithBody generates requests for PostMangaIdStatus with any type of body
func NewPostMangaIdStatusRequestWithBody(server string, id openapi_types.UUID, params *PostMangaIdStatusParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/status", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetMangaRelationRequest generates requests for GetMangaRelation
func NewGetMangaRelationRequest(server string, mangaId openapi_types.UUID, params *GetMangaRelationParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mangaId", runtime.ParamLocationPath, mangaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/relation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostMangaRelationRequest calls the generic PostMangaRelation builder with application/json body
func NewPostMangaRelationRequest(server string, mangaId openapi_types.UUID, params *PostMangaRelationParams, body PostMangaRelationJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostMangaRelationRequestWithBody(server, mangaId, params, "application/json", bodyReader)
}

// NewPostMangaRelationRequestWithBody generates requests for PostMangaRelation with any type of body
func NewPostMangaRelationRequestWithBody(server string, mangaId openapi_types.UUID, params *PostMangaRelationParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mangaId", runtime.ParamLocationPath, mangaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/relation", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewDeleteMangaRelationIdRequest generates requests for DeleteMangaRelationId
func NewDeleteMangaRelationIdRequest(server string, mangaId openapi_types.UUID, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mangaId", runtime.ParamLocationPath, mangaId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/manga/%s/relation/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPingRequest generates requests for GetPing
func NewGetPingRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/ping")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetRatingRequest generates requests for GetRating
func NewGetRatingRequest(server string, params *GetRatingParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rating")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "manga", runtime.ParamLocationQuery, params.Manga); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRatingMangaIdRequest generates requests for DeleteRatingMangaId
func NewDeleteRatingMangaIdRequest(server string, mangaId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mangaId", runtime.ParamLocationPath, mangaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rating/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRatingMangaIdRequest calls the generic PostRatingMangaId builder with application/json body
func NewPostRatingMangaIdRequest(server string, mangaId openapi_types.UUID, body PostRatingMangaIdJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostRatingMangaIdRequestWithBody(server, mangaId, "application/json", bodyReader)
}

// NewPostRatingMangaIdRequestWithBody generates requests for PostRatingMangaId with any type of body
func NewPostRatingMangaIdRequestWithBody(server string, mangaId openapi_types.UUID, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "mangaId", runtime.ParamLocationPath, mangaId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/rating/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetReportsRequest generates requests for GetReports
func NewGetReportsRequest(server string, params *GetReportsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Category != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "category", runtime.ParamLocationQuery, *params.Category); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ReasonId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "reasonId", runtime.ParamLocationQuery, *params.ReasonId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ObjectId != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "objectId", runtime.ParamLocationQuery, *params.ObjectId); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Status != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "status", runtime.ParamLocationQuery, *params.Status); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostReportRequest calls the generic PostReport builder with application/json body
func NewPostReportRequest(server string, params *PostReportParams, body PostReportJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostReportRequestWithBody(server, params, "application/json", bodyReader)
}

// NewPostReportRequestWithBody generates requests for PostReport with any type of body
func NewPostReportRequestWithBody(server string, params *PostReportParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/report")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewGetReportReasonsByCategoryRequest generates requests for GetReportReasonsByCategory
func NewGetReportReasonsByCategoryRequest(server string, category string) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "category", runtime.ParamLocationPath, category)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/report/reasons/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetSettingsRequest generates requests for GetSettings
func NewGetSettingsRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSettingsRequest calls the generic PostSettings builder with application/json body
func NewPostSettingsRequest(server string, body PostSettingsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSettingsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSettingsRequestWithBody generates requests for PostSettings with any type of body
func NewPostSettingsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSettingsTemplateRequest generates requests for GetSettingsTemplate
func NewGetSettingsTemplateRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/template")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSettingsTemplateRequest calls the generic PostSettingsTemplate builder with application/json body
func NewPostSettingsTemplateRequest(server string, body PostSettingsTemplateJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostSettingsTemplateRequestWithBody(server, "application/json", bodyReader)
}

// NewPostSettingsTemplateRequestWithBody generates requests for PostSettingsTemplate with any type of body
func NewPostSettingsTemplateRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/template")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetSettingsTemplateVersionRequest generates requests for GetSettingsTemplateVersion
func NewGetSettingsTemplateVersionRequest(server string, version openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "version", runtime.ParamLocationPath, version)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/settings/template/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatisticsChaptersRequest generates requests for GetStatisticsChapters
func NewGetStatisticsChaptersRequest(server string, params *GetStatisticsChaptersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics/chapter")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "chapter[]", runtime.ParamLocationQuery, params.Chapter); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatisticsChapterUuidRequest generates requests for GetStatisticsChapterUuid
func NewGetStatisticsChapterUuidRequest(server string, uuid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics/chapter/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatisticsGroupsRequest generates requests for GetStatisticsGroups
func NewGetStatisticsGroupsRequest(server string, params *GetStatisticsGroupsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics/group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "group[]", runtime.ParamLocationQuery, params.Group); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatisticsGroupUuidRequest generates requests for GetStatisticsGroupUuid
func NewGetStatisticsGroupUuidRequest(server string, uuid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics/group/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatisticsMangaRequest generates requests for GetStatisticsManga
func NewGetStatisticsMangaRequest(server string, params *GetStatisticsMangaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics/manga")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "manga[]", runtime.ParamLocationQuery, params.Manga); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetStatisticsMangaUuidRequest generates requests for GetStatisticsMangaUuid
func NewGetStatisticsMangaUuidRequest(server string, uuid openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uuid", runtime.ParamLocationPath, uuid)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/statistics/manga/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUploadSessionRequest generates requests for GetUploadSession
func NewGetUploadSessionRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewBeginUploadSessionRequest calls the generic BeginUploadSession builder with application/json body
func NewBeginUploadSessionRequest(server string, params *BeginUploadSessionParams, body BeginUploadSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBeginUploadSessionRequestWithBody(server, params, "application/json", bodyReader)
}

// NewBeginUploadSessionRequestWithBody generates requests for BeginUploadSession with any type of body
func NewBeginUploadSessionRequestWithBody(server string, params *BeginUploadSessionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload/begin")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewBeginEditSessionRequest calls the generic BeginEditSession builder with application/json body
func NewBeginEditSessionRequest(server string, chapterId openapi_types.UUID, params *BeginEditSessionParams, body BeginEditSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewBeginEditSessionRequestWithBody(server, chapterId, params, "application/json", bodyReader)
}

// NewBeginEditSessionRequestWithBody generates requests for BeginEditSession with any type of body
func NewBeginEditSessionRequestWithBody(server string, chapterId openapi_types.UUID, params *BeginEditSessionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "chapterId", runtime.ParamLocationPath, chapterId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload/begin/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewUploadCheckApprovalRequiredRequest calls the generic UploadCheckApprovalRequired builder with application/json body
func NewUploadCheckApprovalRequiredRequest(server string, body UploadCheckApprovalRequiredJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewUploadCheckApprovalRequiredRequestWithBody(server, "application/json", bodyReader)
}

// NewUploadCheckApprovalRequiredRequestWithBody generates requests for UploadCheckApprovalRequired with any type of body
func NewUploadCheckApprovalRequiredRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload/check-approval-required")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewAbandonUploadSessionRequest generates requests for AbandonUploadSession
func NewAbandonUploadSessionRequest(server string, uploadSessionId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uploadSessionId", runtime.ParamLocationPath, uploadSessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutUploadSessionFileRequestWithBody generates requests for PutUploadSessionFile with any type of body
func NewPutUploadSessionFileRequestWithBody(server string, uploadSessionId openapi_types.UUID, params *PutUploadSessionFileParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uploadSessionId", runtime.ParamLocationPath, uploadSessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewDeleteUploadedSessionFilesRequest calls the generic DeleteUploadedSessionFiles builder with application/json body
func NewDeleteUploadedSessionFilesRequest(server string, uploadSessionId openapi_types.UUID, params *DeleteUploadedSessionFilesParams, body DeleteUploadedSessionFilesJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewDeleteUploadedSessionFilesRequestWithBody(server, uploadSessionId, params, "application/json", bodyReader)
}

// NewDeleteUploadedSessionFilesRequestWithBody generates requests for DeleteUploadedSessionFiles with any type of body
func NewDeleteUploadedSessionFilesRequestWithBody(server string, uploadSessionId openapi_types.UUID, params *DeleteUploadedSessionFilesParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uploadSessionId", runtime.ParamLocationPath, uploadSessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload/%s/batch", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewCommitUploadSessionRequest calls the generic CommitUploadSession builder with application/json body
func NewCommitUploadSessionRequest(server string, uploadSessionId openapi_types.UUID, params *CommitUploadSessionParams, body CommitUploadSessionJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewCommitUploadSessionRequestWithBody(server, uploadSessionId, params, "application/json", bodyReader)
}

// NewCommitUploadSessionRequestWithBody generates requests for CommitUploadSession with any type of body
func NewCommitUploadSessionRequestWithBody(server string, uploadSessionId openapi_types.UUID, params *CommitUploadSessionParams, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uploadSessionId", runtime.ParamLocationPath, uploadSessionId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload/%s/commit", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	if params != nil {

		var headerParam0 string

		headerParam0, err = runtime.StyleParamWithLocation("simple", false, "Content-Type", runtime.ParamLocationHeader, params.ContentType)
		if err != nil {
			return nil, err
		}

		req.Header.Set("Content-Type", headerParam0)

	}

	return req, nil
}

// NewDeleteUploadedSessionFileRequest generates requests for DeleteUploadedSessionFile
func NewDeleteUploadedSessionFileRequest(server string, uploadSessionId openapi_types.UUID, uploadSessionFileId openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "uploadSessionId", runtime.ParamLocationPath, uploadSessionId)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "uploadSessionFileId", runtime.ParamLocationPath, uploadSessionFileId)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/upload/%s/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserRequest generates requests for GetUser
func NewGetUserRequest(server string, params *GetUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids[]", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Username != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "username", runtime.ParamLocationQuery, *params.Username); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostUserDeleteCodeRequest generates requests for PostUserDeleteCode
func NewPostUserDeleteCodeRequest(server string, code openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "code", runtime.ParamLocationPath, code)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/delete/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFollowsGroupRequest generates requests for GetUserFollowsGroup
func NewGetUserFollowsGroupRequest(server string, params *GetUserFollowsGroupParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/follows/group")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFollowsGroupIdRequest generates requests for GetUserFollowsGroupId
func NewGetUserFollowsGroupIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/follows/group/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFollowsListRequest generates requests for GetUserFollowsList
func NewGetUserFollowsListRequest(server string, params *GetUserFollowsListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/follows/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFollowsListIdRequest generates requests for GetUserFollowsListId
func NewGetUserFollowsListIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/follows/list/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFollowsMangaRequest generates requests for GetUserFollowsManga
func NewGetUserFollowsMangaRequest(server string, params *GetUserFollowsMangaParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/follows/manga")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFollowsMangaFeedRequest generates requests for GetUserFollowsMangaFeed
func NewGetUserFollowsMangaFeedRequest(server string, params *GetUserFollowsMangaFeedParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/follows/manga/feed")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.TranslatedLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "translatedLanguage[]", runtime.ParamLocationQuery, *params.TranslatedLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.OriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "originalLanguage[]", runtime.ParamLocationQuery, *params.OriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedOriginalLanguage != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedOriginalLanguage[]", runtime.ParamLocationQuery, *params.ExcludedOriginalLanguage); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ContentRating != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "contentRating[]", runtime.ParamLocationQuery, *params.ContentRating); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedGroups != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedGroups[]", runtime.ParamLocationQuery, *params.ExcludedGroups); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ExcludedUploaders != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "excludedUploaders[]", runtime.ParamLocationQuery, *params.ExcludedUploaders); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFutureUpdates != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFutureUpdates", runtime.ParamLocationQuery, *params.IncludeFutureUpdates); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "createdAtSince", runtime.ParamLocationQuery, *params.CreatedAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.UpdatedAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "updatedAtSince", runtime.ParamLocationQuery, *params.UpdatedAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.PublishAtSince != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "publishAtSince", runtime.ParamLocationQuery, *params.PublishAtSince); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Order != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "order", runtime.ParamLocationQuery, *params.Order); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Includes != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includes[]", runtime.ParamLocationQuery, *params.Includes); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeEmptyPages != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeEmptyPages", runtime.ParamLocationQuery, *params.IncludeEmptyPages); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeFuturePublishAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeFuturePublishAt", runtime.ParamLocationQuery, *params.IncludeFuturePublishAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeExternalUrl != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeExternalUrl", runtime.ParamLocationQuery, *params.IncludeExternalUrl); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.IncludeUnavailable != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "includeUnavailable", runtime.ParamLocationQuery, *params.IncludeUnavailable); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFollowsMangaIdRequest generates requests for GetUserFollowsMangaId
func NewGetUserFollowsMangaIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/follows/manga/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFollowsUserRequest generates requests for GetUserFollowsUser
func NewGetUserFollowsUserRequest(server string, params *GetUserFollowsUserParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/follows/user")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserFollowsUserIdRequest generates requests for GetUserFollowsUserId
func NewGetUserFollowsUserIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/follows/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetReadingHistoryRequest generates requests for GetReadingHistory
func NewGetReadingHistoryRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/history")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserListRequest generates requests for GetUserList
func NewGetUserListRequest(server string, params *GetUserListParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/list")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserMeRequest generates requests for GetUserMe
func NewGetUserMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteUserIdRequest generates requests for DeleteUserId
func NewDeleteUserIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserIdRequest generates requests for GetUserId
func NewGetUserIdRequest(server string, id openapi_types.UUID) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUserIdListRequest generates requests for GetUserIdList
func NewGetUserIdListRequest(server string, id openapi_types.UUID, params *GetUserIdListParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "id", runtime.ParamLocationPath, id)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/user/%s/list", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetAtHomeServerChapterIdWithResponse request
	GetAtHomeServerChapterIdWithResponse(ctx context.Context, chapterId openapi_types.UUID, params *GetAtHomeServerChapterIdParams, reqEditors ...RequestEditorFn) (*GetAtHomeServerChapterIdResponse, error)

	// GetAuthCheckWithResponse request
	GetAuthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthCheckResponse, error)

	// PostAuthLoginWithBodyWithResponse request with any body
	PostAuthLoginWithBodyWithResponse(ctx context.Context, params *PostAuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthLoginResponse, error)

	PostAuthLoginWithResponse(ctx context.Context, params *PostAuthLoginParams, body PostAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthLoginResponse, error)

	// PostAuthLogoutWithResponse request
	PostAuthLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostAuthLogoutResponse, error)

	// PostAuthRefreshWithBodyWithResponse request with any body
	PostAuthRefreshWithBodyWithResponse(ctx context.Context, params *PostAuthRefreshParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthRefreshResponse, error)

	PostAuthRefreshWithResponse(ctx context.Context, params *PostAuthRefreshParams, body PostAuthRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthRefreshResponse, error)

	// GetAuthorWithResponse request
	GetAuthorWithResponse(ctx context.Context, params *GetAuthorParams, reqEditors ...RequestEditorFn) (*GetAuthorResponse, error)

	// PostAuthorWithBodyWithResponse request with any body
	PostAuthorWithBodyWithResponse(ctx context.Context, params *PostAuthorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorResponse, error)

	PostAuthorWithResponse(ctx context.Context, params *PostAuthorParams, body PostAuthorJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorResponse, error)

	// DeleteAuthorIdWithResponse request
	DeleteAuthorIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAuthorIdResponse, error)

	// GetAuthorIdWithResponse request
	GetAuthorIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetAuthorIdParams, reqEditors ...RequestEditorFn) (*GetAuthorIdResponse, error)

	// PutAuthorIdWithBodyWithResponse request with any body
	PutAuthorIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PutAuthorIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAuthorIdResponse, error)

	PutAuthorIdWithResponse(ctx context.Context, id openapi_types.UUID, params *PutAuthorIdParams, body PutAuthorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAuthorIdResponse, error)

	// PostCaptchaSolveWithBodyWithResponse request with any body
	PostCaptchaSolveWithBodyWithResponse(ctx context.Context, params *PostCaptchaSolveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCaptchaSolveResponse, error)

	PostCaptchaSolveWithResponse(ctx context.Context, params *PostCaptchaSolveParams, body PostCaptchaSolveJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCaptchaSolveResponse, error)

	// GetChapterWithResponse request
	GetChapterWithResponse(ctx context.Context, params *GetChapterParams, reqEditors ...RequestEditorFn) (*GetChapterResponse, error)

	// DeleteChapterIdWithResponse request
	DeleteChapterIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteChapterIdResponse, error)

	// GetChapterIdWithResponse request
	GetChapterIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetChapterIdParams, reqEditors ...RequestEditorFn) (*GetChapterIdResponse, error)

	// PutChapterIdWithBodyWithResponse request with any body
	PutChapterIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PutChapterIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutChapterIdResponse, error)

	PutChapterIdWithResponse(ctx context.Context, id openapi_types.UUID, params *PutChapterIdParams, body PutChapterIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutChapterIdResponse, error)

	// GetListApiclientsWithResponse request
	GetListApiclientsWithResponse(ctx context.Context, params *GetListApiclientsParams, reqEditors ...RequestEditorFn) (*GetListApiclientsResponse, error)

	// PostCreateApiclientWithBodyWithResponse request with any body
	PostCreateApiclientWithBodyWithResponse(ctx context.Context, params *PostCreateApiclientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateApiclientResponse, error)

	PostCreateApiclientWithResponse(ctx context.Context, params *PostCreateApiclientParams, body PostCreateApiclientJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreateApiclientResponse, error)

	// DeleteApiclientWithResponse request
	DeleteApiclientWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteApiclientParams, reqEditors ...RequestEditorFn) (*DeleteApiclientResponse, error)

	// GetApiclientWithResponse request
	GetApiclientWithResponse(ctx context.Context, id openapi_types.UUID, params *GetApiclientParams, reqEditors ...RequestEditorFn) (*GetApiclientResponse, error)

	// PostEditApiclientWithBodyWithResponse request with any body
	PostEditApiclientWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PostEditApiclientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditApiclientResponse, error)

	PostEditApiclientWithResponse(ctx context.Context, id openapi_types.UUID, params *PostEditApiclientParams, body PostEditApiclientJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditApiclientResponse, error)

	// GetApiclientSecretWithResponse request
	GetApiclientSecretWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetApiclientSecretResponse, error)

	// PostRegenerateApiclientSecretWithBodyWithResponse request with any body
	PostRegenerateApiclientSecretWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PostRegenerateApiclientSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegenerateApiclientSecretResponse, error)

	PostRegenerateApiclientSecretWithResponse(ctx context.Context, id openapi_types.UUID, params *PostRegenerateApiclientSecretParams, body PostRegenerateApiclientSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegenerateApiclientSecretResponse, error)

	// GetCoverWithResponse request
	GetCoverWithResponse(ctx context.Context, params *GetCoverParams, reqEditors ...RequestEditorFn) (*GetCoverResponse, error)

	// DeleteCoverWithResponse request
	DeleteCoverWithResponse(ctx context.Context, mangaOrCoverId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteCoverResponse, error)

	// GetCoverIdWithResponse request
	GetCoverIdWithResponse(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *GetCoverIdParams, reqEditors ...RequestEditorFn) (*GetCoverIdResponse, error)

	// UploadCoverWithBodyWithResponse request with any body
	UploadCoverWithBodyWithResponse(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *UploadCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCoverResponse, error)

	// EditCoverWithBodyWithResponse request with any body
	EditCoverWithBodyWithResponse(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *EditCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCoverResponse, error)

	EditCoverWithResponse(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *EditCoverParams, body EditCoverJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCoverResponse, error)

	// ForumsThreadCreateWithBodyWithResponse request with any body
	ForumsThreadCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForumsThreadCreateResponse, error)

	ForumsThreadCreateWithResponse(ctx context.Context, body ForumsThreadCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ForumsThreadCreateResponse, error)

	// GetSearchGroupWithResponse request
	GetSearchGroupWithResponse(ctx context.Context, params *GetSearchGroupParams, reqEditors ...RequestEditorFn) (*GetSearchGroupResponse, error)

	// PostGroupWithBodyWithResponse request with any body
	PostGroupWithBodyWithResponse(ctx context.Context, params *PostGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGroupResponse, error)

	PostGroupWithResponse(ctx context.Context, params *PostGroupParams, body PostGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGroupResponse, error)

	// DeleteGroupIdWithResponse request
	DeleteGroupIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteGroupIdResponse, error)

	// GetGroupIdWithResponse request
	GetGroupIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetGroupIdParams, reqEditors ...RequestEditorFn) (*GetGroupIdResponse, error)

	// PutGroupIdWithBodyWithResponse request with any body
	PutGroupIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PutGroupIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutGroupIdResponse, error)

	PutGroupIdWithResponse(ctx context.Context, id openapi_types.UUID, params *PutGroupIdParams, body PutGroupIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutGroupIdResponse, error)

	// DeleteGroupIdFollowWithResponse request
	DeleteGroupIdFollowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteGroupIdFollowResponse, error)

	// PostGroupIdFollowWithResponse request
	PostGroupIdFollowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostGroupIdFollowResponse, error)

	// PostLegacyMappingWithBodyWithResponse request with any body
	PostLegacyMappingWithBodyWithResponse(ctx context.Context, params *PostLegacyMappingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLegacyMappingResponse, error)

	PostLegacyMappingWithResponse(ctx context.Context, params *PostLegacyMappingParams, body PostLegacyMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLegacyMappingResponse, error)

	// PostListWithBodyWithResponse request with any body
	PostListWithBodyWithResponse(ctx context.Context, params *PostListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostListResponse, error)

	PostListWithResponse(ctx context.Context, params *PostListParams, body PostListJSONRequestBody, reqEditors ...RequestEditorFn) (*PostListResponse, error)

	// DeleteListIdWithResponse request
	DeleteListIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteListIdResponse, error)

	// GetListIdWithResponse request
	GetListIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetListIdResponse, error)

	// PutListIdWithBodyWithResponse request with any body
	PutListIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PutListIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutListIdResponse, error)

	PutListIdWithResponse(ctx context.Context, id openapi_types.UUID, params *PutListIdParams, body PutListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutListIdResponse, error)

	// GetListIdFeedWithResponse request
	GetListIdFeedWithResponse(ctx context.Context, id openapi_types.UUID, params *GetListIdFeedParams, reqEditors ...RequestEditorFn) (*GetListIdFeedResponse, error)

	// UnfollowListIdWithBodyWithResponse request with any body
	UnfollowListIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnfollowListIdResponse, error)

	UnfollowListIdWithResponse(ctx context.Context, id openapi_types.UUID, body UnfollowListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UnfollowListIdResponse, error)

	// FollowListIdWithBodyWithResponse request with any body
	FollowListIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *FollowListIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FollowListIdResponse, error)

	FollowListIdWithResponse(ctx context.Context, id openapi_types.UUID, params *FollowListIdParams, body FollowListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FollowListIdResponse, error)

	// GetSearchMangaWithResponse request
	GetSearchMangaWithResponse(ctx context.Context, params *GetSearchMangaParams, reqEditors ...RequestEditorFn) (*GetSearchMangaResponse, error)

	// PostMangaWithBodyWithResponse request with any body
	PostMangaWithBodyWithResponse(ctx context.Context, params *PostMangaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMangaResponse, error)

	PostMangaWithResponse(ctx context.Context, params *PostMangaParams, body PostMangaJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMangaResponse, error)

	// GetMangaDraftsWithResponse request
	GetMangaDraftsWithResponse(ctx context.Context, params *GetMangaDraftsParams, reqEditors ...RequestEditorFn) (*GetMangaDraftsResponse, error)

	// GetMangaIdDraftWithResponse request
	GetMangaIdDraftWithResponse(ctx context.Context, id openapi_types.UUID, params *GetMangaIdDraftParams, reqEditors ...RequestEditorFn) (*GetMangaIdDraftResponse, error)

	// CommitMangaDraftWithBodyWithResponse request with any body
	CommitMangaDraftWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitMangaDraftResponse, error)

	CommitMangaDraftWithResponse(ctx context.Context, id openapi_types.UUID, body CommitMangaDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitMangaDraftResponse, error)

	// GetMangaRandomWithResponse request
	GetMangaRandomWithResponse(ctx context.Context, params *GetMangaRandomParams, reqEditors ...RequestEditorFn) (*GetMangaRandomResponse, error)

	// GetMangaChapterReadmarkers2WithResponse request
	GetMangaChapterReadmarkers2WithResponse(ctx context.Context, params *GetMangaChapterReadmarkers2Params, reqEditors ...RequestEditorFn) (*GetMangaChapterReadmarkers2Response, error)

	// GetMangaStatusWithResponse request
	GetMangaStatusWithResponse(ctx context.Context, params *GetMangaStatusParams, reqEditors ...RequestEditorFn) (*GetMangaStatusResponse, error)

	// GetMangaTagWithResponse request
	GetMangaTagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMangaTagResponse, error)

	// DeleteMangaIdWithResponse request
	DeleteMangaIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteMangaIdResponse, error)

	// GetMangaIdWithResponse request
	GetMangaIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetMangaIdParams, reqEditors ...RequestEditorFn) (*GetMangaIdResponse, error)

	// PutMangaIdWithBodyWithResponse request with any body
	PutMangaIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PutMangaIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutMangaIdResponse, error)

	PutMangaIdWithResponse(ctx context.Context, id openapi_types.UUID, params *PutMangaIdParams, body PutMangaIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutMangaIdResponse, error)

	// GetMangaAggregateWithResponse request
	GetMangaAggregateWithResponse(ctx context.Context, id openapi_types.UUID, params *GetMangaAggregateParams, reqEditors ...RequestEditorFn) (*GetMangaAggregateResponse, error)

	// GetMangaIdFeedWithResponse request
	GetMangaIdFeedWithResponse(ctx context.Context, id openapi_types.UUID, params *GetMangaIdFeedParams, reqEditors ...RequestEditorFn) (*GetMangaIdFeedResponse, error)

	// DeleteMangaIdFollowWithResponse request
	DeleteMangaIdFollowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteMangaIdFollowResponse, error)

	// PostMangaIdFollowWithResponse request
	PostMangaIdFollowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostMangaIdFollowResponse, error)

	// DeleteMangaIdListListIdWithResponse request
	DeleteMangaIdListListIdWithResponse(ctx context.Context, id openapi_types.UUID, listId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteMangaIdListListIdResponse, error)

	// PostMangaIdListListIdWithResponse request
	PostMangaIdListListIdWithResponse(ctx context.Context, id openapi_types.UUID, listId openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostMangaIdListListIdResponse, error)

	// GetMangaChapterReadmarkersWithResponse request
	GetMangaChapterReadmarkersWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetMangaChapterReadmarkersResponse, error)

	// PostMangaChapterReadmarkersWithBodyWithResponse request with any body
	PostMangaChapterReadmarkersWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PostMangaChapterReadmarkersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMangaChapterReadmarkersResponse, error)

	PostMangaChapterReadmarkersWithResponse(ctx context.Context, id openapi_types.UUID, params *PostMangaChapterReadmarkersParams, body PostMangaChapterReadmarkersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMangaChapterReadmarkersResponse, error)

	// GetMangaIdStatusWithResponse request
	GetMangaIdStatusWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetMangaIdStatusResponse, error)

	// PostMangaIdStatusWithBodyWithResponse request with any body
	PostMangaIdStatusWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PostMangaIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMangaIdStatusResponse, error)

	PostMangaIdStatusWithResponse(ctx context.Context, id openapi_types.UUID, params *PostMangaIdStatusParams, body PostMangaIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMangaIdStatusResponse, error)

	// GetMangaRelationWithResponse request
	GetMangaRelationWithResponse(ctx context.Context, mangaId openapi_types.UUID, params *GetMangaRelationParams, reqEditors ...RequestEditorFn) (*GetMangaRelationResponse, error)

	// PostMangaRelationWithBodyWithResponse request with any body
	PostMangaRelationWithBodyWithResponse(ctx context.Context, mangaId openapi_types.UUID, params *PostMangaRelationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMangaRelationResponse, error)

	PostMangaRelationWithResponse(ctx context.Context, mangaId openapi_types.UUID, params *PostMangaRelationParams, body PostMangaRelationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMangaRelationResponse, error)

	// DeleteMangaRelationIdWithResponse request
	DeleteMangaRelationIdWithResponse(ctx context.Context, mangaId openapi_types.UUID, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteMangaRelationIdResponse, error)

	// GetPingWithResponse request
	GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPingResponse, error)

	// GetRatingWithResponse request
	GetRatingWithResponse(ctx context.Context, params *GetRatingParams, reqEditors ...RequestEditorFn) (*GetRatingResponse, error)

	// DeleteRatingMangaIdWithResponse request
	DeleteRatingMangaIdWithResponse(ctx context.Context, mangaId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteRatingMangaIdResponse, error)

	// PostRatingMangaIdWithBodyWithResponse request with any body
	PostRatingMangaIdWithBodyWithResponse(ctx context.Context, mangaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRatingMangaIdResponse, error)

	PostRatingMangaIdWithResponse(ctx context.Context, mangaId openapi_types.UUID, body PostRatingMangaIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRatingMangaIdResponse, error)

	// GetReportsWithResponse request
	GetReportsWithResponse(ctx context.Context, params *GetReportsParams, reqEditors ...RequestEditorFn) (*GetReportsResponse, error)

	// PostReportWithBodyWithResponse request with any body
	PostReportWithBodyWithResponse(ctx context.Context, params *PostReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReportResponse, error)

	PostReportWithResponse(ctx context.Context, params *PostReportParams, body PostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReportResponse, error)

	// GetReportReasonsByCategoryWithResponse request
	GetReportReasonsByCategoryWithResponse(ctx context.Context, category string, reqEditors ...RequestEditorFn) (*GetReportReasonsByCategoryResponse, error)

	// GetSettingsWithResponse request
	GetSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error)

	// PostSettingsWithBodyWithResponse request with any body
	PostSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSettingsResponse, error)

	PostSettingsWithResponse(ctx context.Context, body PostSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSettingsResponse, error)

	// GetSettingsTemplateWithResponse request
	GetSettingsTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSettingsTemplateResponse, error)

	// PostSettingsTemplateWithBodyWithResponse request with any body
	PostSettingsTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSettingsTemplateResponse, error)

	PostSettingsTemplateWithResponse(ctx context.Context, body PostSettingsTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSettingsTemplateResponse, error)

	// GetSettingsTemplateVersionWithResponse request
	GetSettingsTemplateVersionWithResponse(ctx context.Context, version openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSettingsTemplateVersionResponse, error)

	// GetStatisticsChaptersWithResponse request
	GetStatisticsChaptersWithResponse(ctx context.Context, params *GetStatisticsChaptersParams, reqEditors ...RequestEditorFn) (*GetStatisticsChaptersResponse, error)

	// GetStatisticsChapterUuidWithResponse request
	GetStatisticsChapterUuidWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetStatisticsChapterUuidResponse, error)

	// GetStatisticsGroupsWithResponse request
	GetStatisticsGroupsWithResponse(ctx context.Context, params *GetStatisticsGroupsParams, reqEditors ...RequestEditorFn) (*GetStatisticsGroupsResponse, error)

	// GetStatisticsGroupUuidWithResponse request
	GetStatisticsGroupUuidWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetStatisticsGroupUuidResponse, error)

	// GetStatisticsMangaWithResponse request
	GetStatisticsMangaWithResponse(ctx context.Context, params *GetStatisticsMangaParams, reqEditors ...RequestEditorFn) (*GetStatisticsMangaResponse, error)

	// GetStatisticsMangaUuidWithResponse request
	GetStatisticsMangaUuidWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetStatisticsMangaUuidResponse, error)

	// GetUploadSessionWithResponse request
	GetUploadSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUploadSessionResponse, error)

	// BeginUploadSessionWithBodyWithResponse request with any body
	BeginUploadSessionWithBodyWithResponse(ctx context.Context, params *BeginUploadSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BeginUploadSessionResponse, error)

	BeginUploadSessionWithResponse(ctx context.Context, params *BeginUploadSessionParams, body BeginUploadSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*BeginUploadSessionResponse, error)

	// BeginEditSessionWithBodyWithResponse request with any body
	BeginEditSessionWithBodyWithResponse(ctx context.Context, chapterId openapi_types.UUID, params *BeginEditSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BeginEditSessionResponse, error)

	BeginEditSessionWithResponse(ctx context.Context, chapterId openapi_types.UUID, params *BeginEditSessionParams, body BeginEditSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*BeginEditSessionResponse, error)

	// UploadCheckApprovalRequiredWithBodyWithResponse request with any body
	UploadCheckApprovalRequiredWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCheckApprovalRequiredResponse, error)

	UploadCheckApprovalRequiredWithResponse(ctx context.Context, body UploadCheckApprovalRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadCheckApprovalRequiredResponse, error)

	// AbandonUploadSessionWithResponse request
	AbandonUploadSessionWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*AbandonUploadSessionResponse, error)

	// PutUploadSessionFileWithBodyWithResponse request with any body
	PutUploadSessionFileWithBodyWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, params *PutUploadSessionFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutUploadSessionFileResponse, error)

	// DeleteUploadedSessionFilesWithBodyWithResponse request with any body
	DeleteUploadedSessionFilesWithBodyWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, params *DeleteUploadedSessionFilesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUploadedSessionFilesResponse, error)

	DeleteUploadedSessionFilesWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, params *DeleteUploadedSessionFilesParams, body DeleteUploadedSessionFilesJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUploadedSessionFilesResponse, error)

	// CommitUploadSessionWithBodyWithResponse request with any body
	CommitUploadSessionWithBodyWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, params *CommitUploadSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitUploadSessionResponse, error)

	CommitUploadSessionWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, params *CommitUploadSessionParams, body CommitUploadSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitUploadSessionResponse, error)

	// DeleteUploadedSessionFileWithResponse request
	DeleteUploadedSessionFileWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, uploadSessionFileId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteUploadedSessionFileResponse, error)

	// GetUserWithResponse request
	GetUserWithResponse(ctx context.Context, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error)

	// PostUserDeleteCodeWithResponse request
	PostUserDeleteCodeWithResponse(ctx context.Context, code openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostUserDeleteCodeResponse, error)

	// GetUserFollowsGroupWithResponse request
	GetUserFollowsGroupWithResponse(ctx context.Context, params *GetUserFollowsGroupParams, reqEditors ...RequestEditorFn) (*GetUserFollowsGroupResponse, error)

	// GetUserFollowsGroupIdWithResponse request
	GetUserFollowsGroupIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserFollowsGroupIdResponse, error)

	// GetUserFollowsListWithResponse request
	GetUserFollowsListWithResponse(ctx context.Context, params *GetUserFollowsListParams, reqEditors ...RequestEditorFn) (*GetUserFollowsListResponse, error)

	// GetUserFollowsListIdWithResponse request
	GetUserFollowsListIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserFollowsListIdResponse, error)

	// GetUserFollowsMangaWithResponse request
	GetUserFollowsMangaWithResponse(ctx context.Context, params *GetUserFollowsMangaParams, reqEditors ...RequestEditorFn) (*GetUserFollowsMangaResponse, error)

	// GetUserFollowsMangaFeedWithResponse request
	GetUserFollowsMangaFeedWithResponse(ctx context.Context, params *GetUserFollowsMangaFeedParams, reqEditors ...RequestEditorFn) (*GetUserFollowsMangaFeedResponse, error)

	// GetUserFollowsMangaIdWithResponse request
	GetUserFollowsMangaIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserFollowsMangaIdResponse, error)

	// GetUserFollowsUserWithResponse request
	GetUserFollowsUserWithResponse(ctx context.Context, params *GetUserFollowsUserParams, reqEditors ...RequestEditorFn) (*GetUserFollowsUserResponse, error)

	// GetUserFollowsUserIdWithResponse request
	GetUserFollowsUserIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserFollowsUserIdResponse, error)

	// GetReadingHistoryWithResponse request
	GetReadingHistoryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadingHistoryResponse, error)

	// GetUserListWithResponse request
	GetUserListWithResponse(ctx context.Context, params *GetUserListParams, reqEditors ...RequestEditorFn) (*GetUserListResponse, error)

	// GetUserMeWithResponse request
	GetUserMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserMeResponse, error)

	// DeleteUserIdWithResponse request
	DeleteUserIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteUserIdResponse, error)

	// GetUserIdWithResponse request
	GetUserIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserIdResponse, error)

	// GetUserIdListWithResponse request
	GetUserIdListWithResponse(ctx context.Context, id openapi_types.UUID, params *GetUserIdListParams, reqEditors ...RequestEditorFn) (*GetUserIdListResponse, error)
}

type GetAtHomeServerChapterIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		// BaseUrl The base URL to construct final image URLs from.
		// The URL returned is valid for the requested chapter only, and for a duration of 15 minutes from the time of the response.
		BaseUrl *string `json:"baseUrl,omitempty"`
		Chapter *struct {
			Data      *[]string `json:"data,omitempty"`
			DataSaver *[]string `json:"dataSaver,omitempty"`
			Hash      *string   `json:"hash,omitempty"`
		} `json:"chapter,omitempty"`
		Result *string `json:"result,omitempty"`
	}
	JSON404 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAtHomeServerChapterIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAtHomeServerChapterIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthCheckResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CheckResponse
}

// Status returns HTTPResponse.Status
func (r GetAuthCheckResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthCheckResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthLoginResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LoginResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostAuthLoginResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthLoginResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthLogoutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *LogoutResponse
	JSON503      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostAuthLogoutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthLogoutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthRefreshResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *RefreshResponse
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostAuthRefreshResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthRefreshResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorList
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAuthorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostAuthorResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostAuthorResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostAuthorResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteAuthorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteAuthorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteAuthorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetAuthorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetAuthorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetAuthorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutAuthorIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *AuthorResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PutAuthorIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutAuthorIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCaptchaSolveResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *PostCaptchaSolve200Result `json:"result,omitempty"`
	}
	JSON400 *ErrorResponse
}
type PostCaptchaSolve200Result string

// Status returns HTTPResponse.Status
func (r PostCaptchaSolveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCaptchaSolveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChapterResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChapterList
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetChapterResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChapterResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteChapterIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteChapterIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteChapterIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetChapterIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChapterResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetChapterIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetChapterIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutChapterIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChapterResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PutChapterIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutChapterIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListApiclientsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiClientList
}

// Status returns HTTPResponse.Status
func (r GetListApiclientsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListApiclientsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostCreateApiclientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiClientResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostCreateApiclientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostCreateApiclientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteApiclientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *string `json:"result,omitempty"`
	}
	JSON403 *ErrorResponse
	JSON404 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteApiclientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteApiclientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiclientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiClientResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetApiclientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiclientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostEditApiclientResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ApiClientResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostEditApiclientResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostEditApiclientResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetApiclientSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *string                      `json:"data,omitempty"`
		Result *GetApiclientSecret200Result `json:"result,omitempty"`
	}
	JSON403 *ErrorResponse
}
type GetApiclientSecret200Result string

// Status returns HTTPResponse.Status
func (r GetApiclientSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetApiclientSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRegenerateApiclientSecretResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *string                                 `json:"data,omitempty"`
		Result *PostRegenerateApiclientSecret200Result `json:"result,omitempty"`
	}
	JSON403 *ErrorResponse
}
type PostRegenerateApiclientSecret200Result string

// Status returns HTTPResponse.Status
func (r PostRegenerateApiclientSecretResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRegenerateApiclientSecretResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoverList
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCoverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteCoverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteCoverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteCoverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetCoverIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoverResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetCoverIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetCoverIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadCoverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoverResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r UploadCoverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadCoverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type EditCoverResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CoverResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r EditCoverResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r EditCoverResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type ForumsThreadCreateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ForumsThreadResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r ForumsThreadCreateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r ForumsThreadCreateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScanlationGroupList
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSearchGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScanlationGroupResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteGroupIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetGroupIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScanlationGroupResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetGroupIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetGroupIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutGroupIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScanlationGroupResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PutGroupIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutGroupIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteGroupIdFollowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteGroupIdFollowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteGroupIdFollowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostGroupIdFollowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostGroupIdFollowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostGroupIdFollowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLegacyMappingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MappingIdResponse
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostLegacyMappingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLegacyMappingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomListResponse
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteListIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteListIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteListIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomListResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetListIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutListIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomListResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PutListIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutListIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetListIdFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChapterList
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetListIdFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetListIdFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UnfollowListIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *UnfollowListId200Result `json:"result,omitempty"`
	}
	JSON403 *ErrorResponse
	JSON404 *ErrorResponse
}
type UnfollowListId200Result string

// Status returns HTTPResponse.Status
func (r UnfollowListIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UnfollowListIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type FollowListIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *FollowListId200Result `json:"result,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON403 *ErrorResponse
	JSON404 *ErrorResponse
}
type FollowListId200Result string

// Status returns HTTPResponse.Status
func (r FollowListIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r FollowListIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSearchMangaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaList
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSearchMangaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSearchMangaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMangaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostMangaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMangaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaDraftsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMangaDraftsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaDraftsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaIdDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMangaIdDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaIdDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitMangaDraftResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *MangaResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r CommitMangaDraftResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitMangaDraftResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaRandomResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaResponse
}

// Status returns HTTPResponse.Status
func (r GetMangaRandomResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaRandomResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaChapterReadmarkers2Response struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *GetMangaChapterReadmarkers2_200_Data `json:"data,omitempty"`
		Result *GetMangaChapterReadmarkers2200Result `json:"result,omitempty"`
	}
}
type GetMangaChapterReadmarkers2200Data0 = []openapi_types.UUID
type GetMangaChapterReadmarkers2200Data1 map[string][]openapi_types.UUID
type GetMangaChapterReadmarkers2_200_Data struct {
	union json.RawMessage
}
type GetMangaChapterReadmarkers2200Result string

// Status returns HTTPResponse.Status
func (r GetMangaChapterReadmarkers2Response) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaChapterReadmarkers2Response) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result   *string                               `json:"result,omitempty"`
		Statuses *map[string]GetMangaStatus200Statuses `json:"statuses,omitempty"`
	}
}
type GetMangaStatus200Statuses string

// Status returns HTTPResponse.Status
func (r GetMangaStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaTagResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *TagResponse
}

// Status returns HTTPResponse.Status
func (r GetMangaTagResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaTagResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMangaIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMangaIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMangaIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMangaIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutMangaIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PutMangaIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutMangaIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaAggregateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result  *string `json:"result,omitempty"`
		Volumes *map[string]struct {
			Chapters *map[string]struct {
				Chapter *string               `json:"chapter,omitempty"`
				Count   *int                  `json:"count,omitempty"`
				Id      *openapi_types.UUID   `json:"id,omitempty"`
				Others  *[]openapi_types.UUID `json:"others,omitempty"`
			} `json:"chapters,omitempty"`
			Count  *int    `json:"count,omitempty"`
			Volume *string `json:"volume,omitempty"`
		} `json:"volumes,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetMangaAggregateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaAggregateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaIdFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChapterList
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMangaIdFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaIdFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMangaIdFollowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMangaIdFollowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMangaIdFollowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMangaIdFollowResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostMangaIdFollowResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMangaIdFollowResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMangaIdListListIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMangaIdListListIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMangaIdListListIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMangaIdListListIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostMangaIdListListIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMangaIdListListIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaChapterReadmarkersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]openapi_types.UUID                `json:"data,omitempty"`
		Result *GetMangaChapterReadmarkers200Result `json:"result,omitempty"`
	}
}
type GetMangaChapterReadmarkers200Result string

// Status returns HTTPResponse.Status
func (r GetMangaChapterReadmarkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaChapterReadmarkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMangaChapterReadmarkersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *PostMangaChapterReadmarkers200Result `json:"result,omitempty"`
	}
}
type PostMangaChapterReadmarkers200Result string

// Status returns HTTPResponse.Status
func (r PostMangaChapterReadmarkersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMangaChapterReadmarkersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaIdStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *string                    `json:"result,omitempty"`
		Status *GetMangaIdStatus200Status `json:"status,omitempty"`
	}
	JSON403 *ErrorResponse
	JSON404 *ErrorResponse
}
type GetMangaIdStatus200Status string

// Status returns HTTPResponse.Status
func (r GetMangaIdStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaIdStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMangaIdStatusResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostMangaIdStatusResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMangaIdStatusResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMangaRelationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaRelationList
	JSON400      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetMangaRelationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMangaRelationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostMangaRelationResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaRelationResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostMangaRelationResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostMangaRelationResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMangaRelationIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteMangaRelationIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMangaRelationIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r GetPingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetRatingResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ratings *map[string]struct {
			CreatedAt *time.Time `json:"createdAt,omitempty"`
			Rating    *int       `json:"rating,omitempty"`
		} `json:"ratings,omitempty"`
		Result *string `json:"result,omitempty"`
	}
	JSON403 *ErrorResponse
	JSON404 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetRatingResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetRatingResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRatingMangaIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r DeleteRatingMangaIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRatingMangaIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRatingMangaIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostRatingMangaIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRatingMangaIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ReportListResponse
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetReportsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostReportResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON201      *Response
	JSON400      *ErrorResponse
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostReportResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostReportResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReportReasonsByCategoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data *[]struct {
			Attributes *struct {
				Category        *GetReportReasonsByCategory200DataAttributesCategory `json:"category,omitempty"`
				DetailsRequired *bool                                                `json:"detailsRequired,omitempty"`
				Reason          *LocalizedString                                     `json:"reason,omitempty"`
				Version         *int                                                 `json:"version,omitempty"`
			} `json:"attributes,omitempty"`
			Id   *openapi_types.UUID `json:"id,omitempty"`
			Type *string             `json:"type,omitempty"`
		} `json:"data,omitempty"`
		Limit    *int    `json:"limit,omitempty"`
		Offset   *int    `json:"offset,omitempty"`
		Response *string `json:"response,omitempty"`
		Result   *string `json:"result,omitempty"`
		Total    *int    `json:"total,omitempty"`
	}
	JSON400 *ErrorResponse
	JSON403 *ErrorResponse
	JSON404 *ErrorResponse
}
type GetReportReasonsByCategory200DataAttributesCategory string

// Status returns HTTPResponse.Status
func (r GetReportReasonsByCategoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReportReasonsByCategoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *string `json:"result,omitempty"`

		// Settings Settings that were validated by linked template
		Settings *map[string]interface{} `json:"settings,omitempty"`

		// Template Settings template UUID
		Template  *openapi_types.UUID `json:"template,omitempty"`
		UpdatedAt *time.Time          `json:"updatedAt,omitempty"`
	}
	JSON403 *ErrorResponse
	JSON404 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSettingsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result *string `json:"result,omitempty"`

		// Settings Settings that were validated against the linked template
		Settings *map[string]interface{} `json:"settings,omitempty"`

		// Template Settings template UUID
		Template  *openapi_types.UUID `json:"template,omitempty"`
		UpdatedAt *time.Time          `json:"updatedAt,omitempty"`
	}
	JSON403 *ErrorResponse
	JSON404 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostSettingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSettingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSettingsTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSettingsTemplateResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON403      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r PostSettingsTemplateResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSettingsTemplateResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetSettingsTemplateVersionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *map[string]interface{}
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetSettingsTemplateVersionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetSettingsTemplateVersionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatisticsChaptersResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result     *string `json:"result,omitempty"`
		Statistics *map[string]struct {
			// Comments Comments-related statistics of an entity.
			// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
			Comments *StatisticsDetailsComments `json:"comments"`
		} `json:"statistics,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatisticsChaptersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatisticsChaptersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatisticsChapterUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result     *string `json:"result,omitempty"`
		Statistics *map[string]struct {
			// Comments Comments-related statistics of an entity.
			// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
			Comments *StatisticsDetailsComments `json:"comments"`
		} `json:"statistics,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatisticsChapterUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatisticsChapterUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatisticsGroupsResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result     *string `json:"result,omitempty"`
		Statistics *map[string]struct {
			// Comments Comments-related statistics of an entity.
			// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
			Comments *StatisticsDetailsComments `json:"comments"`
		} `json:"statistics,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatisticsGroupsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatisticsGroupsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatisticsGroupUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result     *string `json:"result,omitempty"`
		Statistics *map[string]struct {
			// Comments Comments-related statistics of an entity.
			// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
			Comments *StatisticsDetailsComments `json:"comments"`
		} `json:"statistics,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatisticsGroupUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatisticsGroupUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatisticsMangaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result     *string `json:"result,omitempty"`
		Statistics *map[string]struct {
			// Comments Comments-related statistics of an entity.
			// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
			Comments *StatisticsDetailsComments `json:"comments"`
			Follows  *int                       `json:"follows,omitempty"`
			Rating   *struct {
				// Average Will be nullable if no ratings has been done
				Average *float32 `json:"average"`

				// Bayesian Average weighted on all the Manga population
				Bayesian *float32 `json:"bayesian,omitempty"`
			} `json:"rating,omitempty"`
		} `json:"statistics,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatisticsMangaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatisticsMangaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetStatisticsMangaUuidResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Result     *string `json:"result,omitempty"`
		Statistics *map[string]struct {
			// Comments Comments-related statistics of an entity.
			// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
			Comments *StatisticsDetailsComments `json:"comments"`
			Follows  *int                       `json:"follows,omitempty"`
			Rating   *struct {
				// Average Will be nullable if no ratings has been given
				Average *float32 `json:"average"`

				// Bayesian Average weighted on all the Manga population
				Bayesian     *float32 `json:"bayesian,omitempty"`
				Distribution *struct {
					N1  *int `json:"1,omitempty"`
					N10 *int `json:"10,omitempty"`
					N2  *int `json:"2,omitempty"`
					N3  *int `json:"3,omitempty"`
					N4  *int `json:"4,omitempty"`
					N5  *int `json:"5,omitempty"`
					N6  *int `json:"6,omitempty"`
					N7  *int `json:"7,omitempty"`
					N8  *int `json:"8,omitempty"`
					N9  *int `json:"9,omitempty"`
				} `json:"distribution,omitempty"`
			} `json:"rating,omitempty"`
			UnavailableChapterCount *int `json:"unavailableChapterCount,omitempty"`
		} `json:"statistics,omitempty"`
	}
}

// Status returns HTTPResponse.Status
func (r GetStatisticsMangaUuidResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetStatisticsMangaUuidResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUploadSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadSession
	JSON403      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUploadSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUploadSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BeginUploadSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadSession
}

// Status returns HTTPResponse.Status
func (r BeginUploadSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BeginUploadSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type BeginEditSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UploadSession
	JSON400      *ErrorResponse
	JSON401      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r BeginEditSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r BeginEditSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type UploadCheckApprovalRequiredResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		RequiresApproval *bool                                 `json:"requiresApproval,omitempty"`
		Result           *UploadCheckApprovalRequired200Result `json:"result,omitempty"`
	}
	JSON404 *Response
}
type UploadCheckApprovalRequired200Result string

// Status returns HTTPResponse.Status
func (r UploadCheckApprovalRequiredResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r UploadCheckApprovalRequiredResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type AbandonUploadSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
}

// Status returns HTTPResponse.Status
func (r AbandonUploadSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r AbandonUploadSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutUploadSessionFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Data   *[]UploadSessionFile           `json:"data,omitempty"`
		Errors *[]Error                       `json:"errors,omitempty"`
		Result *PutUploadSessionFile200Result `json:"result,omitempty"`
	}
	JSON400 *ErrorResponse
}
type PutUploadSessionFile200Result string

// Status returns HTTPResponse.Status
func (r PutUploadSessionFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutUploadSessionFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUploadedSessionFilesResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
}

// Status returns HTTPResponse.Status
func (r DeleteUploadedSessionFilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUploadedSessionFilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type CommitUploadSessionResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Chapter
}

// Status returns HTTPResponse.Status
func (r CommitUploadSessionResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r CommitUploadSessionResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUploadedSessionFileResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
}

// Status returns HTTPResponse.Status
func (r DeleteUploadedSessionFileResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUploadedSessionFileResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
}

// Status returns HTTPResponse.Status
func (r GetUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostUserDeleteCodeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
}

// Status returns HTTPResponse.Status
func (r PostUserDeleteCodeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostUserDeleteCodeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFollowsGroupResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ScanlationGroupList
}

// Status returns HTTPResponse.Status
func (r GetUserFollowsGroupResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFollowsGroupResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFollowsGroupIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r GetUserFollowsGroupIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFollowsGroupIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFollowsListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomListList
}

// Status returns HTTPResponse.Status
func (r GetUserFollowsListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFollowsListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFollowsListIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r GetUserFollowsListIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFollowsListIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFollowsMangaResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *MangaList
}

// Status returns HTTPResponse.Status
func (r GetUserFollowsMangaResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFollowsMangaResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFollowsMangaFeedResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *ChapterList
	JSON400      *ErrorResponse
	JSON404      *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetUserFollowsMangaFeedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFollowsMangaFeedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFollowsMangaIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r GetUserFollowsMangaIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFollowsMangaIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFollowsUserResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserList
}

// Status returns HTTPResponse.Status
func (r GetUserFollowsUserResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFollowsUserResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserFollowsUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
	JSON404      *Response
}

// Status returns HTTPResponse.Status
func (r GetUserFollowsUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserFollowsUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetReadingHistoryResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *struct {
		Ratings *[]struct {
			ChapterId *string    `json:"chapterId,omitempty"`
			ReadDate  *time.Time `json:"readDate,omitempty"`
		} `json:"ratings,omitempty"`
		Result *string `json:"result,omitempty"`
	}
	JSON403 *ErrorResponse
	JSON404 *ErrorResponse
}

// Status returns HTTPResponse.Status
func (r GetReadingHistoryResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetReadingHistoryResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomListList
}

// Status returns HTTPResponse.Status
func (r GetUserListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserMeResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
}

// Status returns HTTPResponse.Status
func (r GetUserMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *Response
}

// Status returns HTTPResponse.Status
func (r DeleteUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserIdResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *UserResponse
}

// Status returns HTTPResponse.Status
func (r GetUserIdResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserIdResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUserIdListResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON200      *CustomListList
}

// Status returns HTTPResponse.Status
func (r GetUserIdListResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUserIdListResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetAtHomeServerChapterIdWithResponse request returning *GetAtHomeServerChapterIdResponse
func (c *ClientWithResponses) GetAtHomeServerChapterIdWithResponse(ctx context.Context, chapterId openapi_types.UUID, params *GetAtHomeServerChapterIdParams, reqEditors ...RequestEditorFn) (*GetAtHomeServerChapterIdResponse, error) {
	rsp, err := c.GetAtHomeServerChapterId(ctx, chapterId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAtHomeServerChapterIdResponse(rsp)
}

// GetAuthCheckWithResponse request returning *GetAuthCheckResponse
func (c *ClientWithResponses) GetAuthCheckWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetAuthCheckResponse, error) {
	rsp, err := c.GetAuthCheck(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthCheckResponse(rsp)
}

// PostAuthLoginWithBodyWithResponse request with arbitrary body returning *PostAuthLoginResponse
func (c *ClientWithResponses) PostAuthLoginWithBodyWithResponse(ctx context.Context, params *PostAuthLoginParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthLoginResponse, error) {
	rsp, err := c.PostAuthLoginWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthLoginResponse(rsp)
}

func (c *ClientWithResponses) PostAuthLoginWithResponse(ctx context.Context, params *PostAuthLoginParams, body PostAuthLoginJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthLoginResponse, error) {
	rsp, err := c.PostAuthLogin(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthLoginResponse(rsp)
}

// PostAuthLogoutWithResponse request returning *PostAuthLogoutResponse
func (c *ClientWithResponses) PostAuthLogoutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostAuthLogoutResponse, error) {
	rsp, err := c.PostAuthLogout(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthLogoutResponse(rsp)
}

// PostAuthRefreshWithBodyWithResponse request with arbitrary body returning *PostAuthRefreshResponse
func (c *ClientWithResponses) PostAuthRefreshWithBodyWithResponse(ctx context.Context, params *PostAuthRefreshParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthRefreshResponse, error) {
	rsp, err := c.PostAuthRefreshWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthRefreshResponse(rsp)
}

func (c *ClientWithResponses) PostAuthRefreshWithResponse(ctx context.Context, params *PostAuthRefreshParams, body PostAuthRefreshJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthRefreshResponse, error) {
	rsp, err := c.PostAuthRefresh(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthRefreshResponse(rsp)
}

// GetAuthorWithResponse request returning *GetAuthorResponse
func (c *ClientWithResponses) GetAuthorWithResponse(ctx context.Context, params *GetAuthorParams, reqEditors ...RequestEditorFn) (*GetAuthorResponse, error) {
	rsp, err := c.GetAuthor(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorResponse(rsp)
}

// PostAuthorWithBodyWithResponse request with arbitrary body returning *PostAuthorResponse
func (c *ClientWithResponses) PostAuthorWithBodyWithResponse(ctx context.Context, params *PostAuthorParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostAuthorResponse, error) {
	rsp, err := c.PostAuthorWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorResponse(rsp)
}

func (c *ClientWithResponses) PostAuthorWithResponse(ctx context.Context, params *PostAuthorParams, body PostAuthorJSONRequestBody, reqEditors ...RequestEditorFn) (*PostAuthorResponse, error) {
	rsp, err := c.PostAuthor(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostAuthorResponse(rsp)
}

// DeleteAuthorIdWithResponse request returning *DeleteAuthorIdResponse
func (c *ClientWithResponses) DeleteAuthorIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteAuthorIdResponse, error) {
	rsp, err := c.DeleteAuthorId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteAuthorIdResponse(rsp)
}

// GetAuthorIdWithResponse request returning *GetAuthorIdResponse
func (c *ClientWithResponses) GetAuthorIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetAuthorIdParams, reqEditors ...RequestEditorFn) (*GetAuthorIdResponse, error) {
	rsp, err := c.GetAuthorId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetAuthorIdResponse(rsp)
}

// PutAuthorIdWithBodyWithResponse request with arbitrary body returning *PutAuthorIdResponse
func (c *ClientWithResponses) PutAuthorIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PutAuthorIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutAuthorIdResponse, error) {
	rsp, err := c.PutAuthorIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAuthorIdResponse(rsp)
}

func (c *ClientWithResponses) PutAuthorIdWithResponse(ctx context.Context, id openapi_types.UUID, params *PutAuthorIdParams, body PutAuthorIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutAuthorIdResponse, error) {
	rsp, err := c.PutAuthorId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutAuthorIdResponse(rsp)
}

// PostCaptchaSolveWithBodyWithResponse request with arbitrary body returning *PostCaptchaSolveResponse
func (c *ClientWithResponses) PostCaptchaSolveWithBodyWithResponse(ctx context.Context, params *PostCaptchaSolveParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCaptchaSolveResponse, error) {
	rsp, err := c.PostCaptchaSolveWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCaptchaSolveResponse(rsp)
}

func (c *ClientWithResponses) PostCaptchaSolveWithResponse(ctx context.Context, params *PostCaptchaSolveParams, body PostCaptchaSolveJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCaptchaSolveResponse, error) {
	rsp, err := c.PostCaptchaSolve(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCaptchaSolveResponse(rsp)
}

// GetChapterWithResponse request returning *GetChapterResponse
func (c *ClientWithResponses) GetChapterWithResponse(ctx context.Context, params *GetChapterParams, reqEditors ...RequestEditorFn) (*GetChapterResponse, error) {
	rsp, err := c.GetChapter(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChapterResponse(rsp)
}

// DeleteChapterIdWithResponse request returning *DeleteChapterIdResponse
func (c *ClientWithResponses) DeleteChapterIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteChapterIdResponse, error) {
	rsp, err := c.DeleteChapterId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteChapterIdResponse(rsp)
}

// GetChapterIdWithResponse request returning *GetChapterIdResponse
func (c *ClientWithResponses) GetChapterIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetChapterIdParams, reqEditors ...RequestEditorFn) (*GetChapterIdResponse, error) {
	rsp, err := c.GetChapterId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetChapterIdResponse(rsp)
}

// PutChapterIdWithBodyWithResponse request with arbitrary body returning *PutChapterIdResponse
func (c *ClientWithResponses) PutChapterIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PutChapterIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutChapterIdResponse, error) {
	rsp, err := c.PutChapterIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutChapterIdResponse(rsp)
}

func (c *ClientWithResponses) PutChapterIdWithResponse(ctx context.Context, id openapi_types.UUID, params *PutChapterIdParams, body PutChapterIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutChapterIdResponse, error) {
	rsp, err := c.PutChapterId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutChapterIdResponse(rsp)
}

// GetListApiclientsWithResponse request returning *GetListApiclientsResponse
func (c *ClientWithResponses) GetListApiclientsWithResponse(ctx context.Context, params *GetListApiclientsParams, reqEditors ...RequestEditorFn) (*GetListApiclientsResponse, error) {
	rsp, err := c.GetListApiclients(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListApiclientsResponse(rsp)
}

// PostCreateApiclientWithBodyWithResponse request with arbitrary body returning *PostCreateApiclientResponse
func (c *ClientWithResponses) PostCreateApiclientWithBodyWithResponse(ctx context.Context, params *PostCreateApiclientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostCreateApiclientResponse, error) {
	rsp, err := c.PostCreateApiclientWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateApiclientResponse(rsp)
}

func (c *ClientWithResponses) PostCreateApiclientWithResponse(ctx context.Context, params *PostCreateApiclientParams, body PostCreateApiclientJSONRequestBody, reqEditors ...RequestEditorFn) (*PostCreateApiclientResponse, error) {
	rsp, err := c.PostCreateApiclient(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostCreateApiclientResponse(rsp)
}

// DeleteApiclientWithResponse request returning *DeleteApiclientResponse
func (c *ClientWithResponses) DeleteApiclientWithResponse(ctx context.Context, id openapi_types.UUID, params *DeleteApiclientParams, reqEditors ...RequestEditorFn) (*DeleteApiclientResponse, error) {
	rsp, err := c.DeleteApiclient(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteApiclientResponse(rsp)
}

// GetApiclientWithResponse request returning *GetApiclientResponse
func (c *ClientWithResponses) GetApiclientWithResponse(ctx context.Context, id openapi_types.UUID, params *GetApiclientParams, reqEditors ...RequestEditorFn) (*GetApiclientResponse, error) {
	rsp, err := c.GetApiclient(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiclientResponse(rsp)
}

// PostEditApiclientWithBodyWithResponse request with arbitrary body returning *PostEditApiclientResponse
func (c *ClientWithResponses) PostEditApiclientWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PostEditApiclientParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostEditApiclientResponse, error) {
	rsp, err := c.PostEditApiclientWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditApiclientResponse(rsp)
}

func (c *ClientWithResponses) PostEditApiclientWithResponse(ctx context.Context, id openapi_types.UUID, params *PostEditApiclientParams, body PostEditApiclientJSONRequestBody, reqEditors ...RequestEditorFn) (*PostEditApiclientResponse, error) {
	rsp, err := c.PostEditApiclient(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostEditApiclientResponse(rsp)
}

// GetApiclientSecretWithResponse request returning *GetApiclientSecretResponse
func (c *ClientWithResponses) GetApiclientSecretWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetApiclientSecretResponse, error) {
	rsp, err := c.GetApiclientSecret(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetApiclientSecretResponse(rsp)
}

// PostRegenerateApiclientSecretWithBodyWithResponse request with arbitrary body returning *PostRegenerateApiclientSecretResponse
func (c *ClientWithResponses) PostRegenerateApiclientSecretWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PostRegenerateApiclientSecretParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRegenerateApiclientSecretResponse, error) {
	rsp, err := c.PostRegenerateApiclientSecretWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegenerateApiclientSecretResponse(rsp)
}

func (c *ClientWithResponses) PostRegenerateApiclientSecretWithResponse(ctx context.Context, id openapi_types.UUID, params *PostRegenerateApiclientSecretParams, body PostRegenerateApiclientSecretJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRegenerateApiclientSecretResponse, error) {
	rsp, err := c.PostRegenerateApiclientSecret(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRegenerateApiclientSecretResponse(rsp)
}

// GetCoverWithResponse request returning *GetCoverResponse
func (c *ClientWithResponses) GetCoverWithResponse(ctx context.Context, params *GetCoverParams, reqEditors ...RequestEditorFn) (*GetCoverResponse, error) {
	rsp, err := c.GetCover(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoverResponse(rsp)
}

// DeleteCoverWithResponse request returning *DeleteCoverResponse
func (c *ClientWithResponses) DeleteCoverWithResponse(ctx context.Context, mangaOrCoverId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteCoverResponse, error) {
	rsp, err := c.DeleteCover(ctx, mangaOrCoverId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteCoverResponse(rsp)
}

// GetCoverIdWithResponse request returning *GetCoverIdResponse
func (c *ClientWithResponses) GetCoverIdWithResponse(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *GetCoverIdParams, reqEditors ...RequestEditorFn) (*GetCoverIdResponse, error) {
	rsp, err := c.GetCoverId(ctx, mangaOrCoverId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetCoverIdResponse(rsp)
}

// UploadCoverWithBodyWithResponse request with arbitrary body returning *UploadCoverResponse
func (c *ClientWithResponses) UploadCoverWithBodyWithResponse(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *UploadCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCoverResponse, error) {
	rsp, err := c.UploadCoverWithBody(ctx, mangaOrCoverId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCoverResponse(rsp)
}

// EditCoverWithBodyWithResponse request with arbitrary body returning *EditCoverResponse
func (c *ClientWithResponses) EditCoverWithBodyWithResponse(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *EditCoverParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*EditCoverResponse, error) {
	rsp, err := c.EditCoverWithBody(ctx, mangaOrCoverId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCoverResponse(rsp)
}

func (c *ClientWithResponses) EditCoverWithResponse(ctx context.Context, mangaOrCoverId openapi_types.UUID, params *EditCoverParams, body EditCoverJSONRequestBody, reqEditors ...RequestEditorFn) (*EditCoverResponse, error) {
	rsp, err := c.EditCover(ctx, mangaOrCoverId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseEditCoverResponse(rsp)
}

// ForumsThreadCreateWithBodyWithResponse request with arbitrary body returning *ForumsThreadCreateResponse
func (c *ClientWithResponses) ForumsThreadCreateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*ForumsThreadCreateResponse, error) {
	rsp, err := c.ForumsThreadCreateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForumsThreadCreateResponse(rsp)
}

func (c *ClientWithResponses) ForumsThreadCreateWithResponse(ctx context.Context, body ForumsThreadCreateJSONRequestBody, reqEditors ...RequestEditorFn) (*ForumsThreadCreateResponse, error) {
	rsp, err := c.ForumsThreadCreate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseForumsThreadCreateResponse(rsp)
}

// GetSearchGroupWithResponse request returning *GetSearchGroupResponse
func (c *ClientWithResponses) GetSearchGroupWithResponse(ctx context.Context, params *GetSearchGroupParams, reqEditors ...RequestEditorFn) (*GetSearchGroupResponse, error) {
	rsp, err := c.GetSearchGroup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchGroupResponse(rsp)
}

// PostGroupWithBodyWithResponse request with arbitrary body returning *PostGroupResponse
func (c *ClientWithResponses) PostGroupWithBodyWithResponse(ctx context.Context, params *PostGroupParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostGroupResponse, error) {
	rsp, err := c.PostGroupWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGroupResponse(rsp)
}

func (c *ClientWithResponses) PostGroupWithResponse(ctx context.Context, params *PostGroupParams, body PostGroupJSONRequestBody, reqEditors ...RequestEditorFn) (*PostGroupResponse, error) {
	rsp, err := c.PostGroup(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGroupResponse(rsp)
}

// DeleteGroupIdWithResponse request returning *DeleteGroupIdResponse
func (c *ClientWithResponses) DeleteGroupIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteGroupIdResponse, error) {
	rsp, err := c.DeleteGroupId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupIdResponse(rsp)
}

// GetGroupIdWithResponse request returning *GetGroupIdResponse
func (c *ClientWithResponses) GetGroupIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetGroupIdParams, reqEditors ...RequestEditorFn) (*GetGroupIdResponse, error) {
	rsp, err := c.GetGroupId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetGroupIdResponse(rsp)
}

// PutGroupIdWithBodyWithResponse request with arbitrary body returning *PutGroupIdResponse
func (c *ClientWithResponses) PutGroupIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PutGroupIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutGroupIdResponse, error) {
	rsp, err := c.PutGroupIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutGroupIdResponse(rsp)
}

func (c *ClientWithResponses) PutGroupIdWithResponse(ctx context.Context, id openapi_types.UUID, params *PutGroupIdParams, body PutGroupIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutGroupIdResponse, error) {
	rsp, err := c.PutGroupId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutGroupIdResponse(rsp)
}

// DeleteGroupIdFollowWithResponse request returning *DeleteGroupIdFollowResponse
func (c *ClientWithResponses) DeleteGroupIdFollowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteGroupIdFollowResponse, error) {
	rsp, err := c.DeleteGroupIdFollow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteGroupIdFollowResponse(rsp)
}

// PostGroupIdFollowWithResponse request returning *PostGroupIdFollowResponse
func (c *ClientWithResponses) PostGroupIdFollowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostGroupIdFollowResponse, error) {
	rsp, err := c.PostGroupIdFollow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostGroupIdFollowResponse(rsp)
}

// PostLegacyMappingWithBodyWithResponse request with arbitrary body returning *PostLegacyMappingResponse
func (c *ClientWithResponses) PostLegacyMappingWithBodyWithResponse(ctx context.Context, params *PostLegacyMappingParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostLegacyMappingResponse, error) {
	rsp, err := c.PostLegacyMappingWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLegacyMappingResponse(rsp)
}

func (c *ClientWithResponses) PostLegacyMappingWithResponse(ctx context.Context, params *PostLegacyMappingParams, body PostLegacyMappingJSONRequestBody, reqEditors ...RequestEditorFn) (*PostLegacyMappingResponse, error) {
	rsp, err := c.PostLegacyMapping(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLegacyMappingResponse(rsp)
}

// PostListWithBodyWithResponse request with arbitrary body returning *PostListResponse
func (c *ClientWithResponses) PostListWithBodyWithResponse(ctx context.Context, params *PostListParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostListResponse, error) {
	rsp, err := c.PostListWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostListResponse(rsp)
}

func (c *ClientWithResponses) PostListWithResponse(ctx context.Context, params *PostListParams, body PostListJSONRequestBody, reqEditors ...RequestEditorFn) (*PostListResponse, error) {
	rsp, err := c.PostList(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostListResponse(rsp)
}

// DeleteListIdWithResponse request returning *DeleteListIdResponse
func (c *ClientWithResponses) DeleteListIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteListIdResponse, error) {
	rsp, err := c.DeleteListId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteListIdResponse(rsp)
}

// GetListIdWithResponse request returning *GetListIdResponse
func (c *ClientWithResponses) GetListIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetListIdResponse, error) {
	rsp, err := c.GetListId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListIdResponse(rsp)
}

// PutListIdWithBodyWithResponse request with arbitrary body returning *PutListIdResponse
func (c *ClientWithResponses) PutListIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PutListIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutListIdResponse, error) {
	rsp, err := c.PutListIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutListIdResponse(rsp)
}

func (c *ClientWithResponses) PutListIdWithResponse(ctx context.Context, id openapi_types.UUID, params *PutListIdParams, body PutListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutListIdResponse, error) {
	rsp, err := c.PutListId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutListIdResponse(rsp)
}

// GetListIdFeedWithResponse request returning *GetListIdFeedResponse
func (c *ClientWithResponses) GetListIdFeedWithResponse(ctx context.Context, id openapi_types.UUID, params *GetListIdFeedParams, reqEditors ...RequestEditorFn) (*GetListIdFeedResponse, error) {
	rsp, err := c.GetListIdFeed(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetListIdFeedResponse(rsp)
}

// UnfollowListIdWithBodyWithResponse request with arbitrary body returning *UnfollowListIdResponse
func (c *ClientWithResponses) UnfollowListIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UnfollowListIdResponse, error) {
	rsp, err := c.UnfollowListIdWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnfollowListIdResponse(rsp)
}

func (c *ClientWithResponses) UnfollowListIdWithResponse(ctx context.Context, id openapi_types.UUID, body UnfollowListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*UnfollowListIdResponse, error) {
	rsp, err := c.UnfollowListId(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUnfollowListIdResponse(rsp)
}

// FollowListIdWithBodyWithResponse request with arbitrary body returning *FollowListIdResponse
func (c *ClientWithResponses) FollowListIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *FollowListIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*FollowListIdResponse, error) {
	rsp, err := c.FollowListIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowListIdResponse(rsp)
}

func (c *ClientWithResponses) FollowListIdWithResponse(ctx context.Context, id openapi_types.UUID, params *FollowListIdParams, body FollowListIdJSONRequestBody, reqEditors ...RequestEditorFn) (*FollowListIdResponse, error) {
	rsp, err := c.FollowListId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseFollowListIdResponse(rsp)
}

// GetSearchMangaWithResponse request returning *GetSearchMangaResponse
func (c *ClientWithResponses) GetSearchMangaWithResponse(ctx context.Context, params *GetSearchMangaParams, reqEditors ...RequestEditorFn) (*GetSearchMangaResponse, error) {
	rsp, err := c.GetSearchManga(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSearchMangaResponse(rsp)
}

// PostMangaWithBodyWithResponse request with arbitrary body returning *PostMangaResponse
func (c *ClientWithResponses) PostMangaWithBodyWithResponse(ctx context.Context, params *PostMangaParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMangaResponse, error) {
	rsp, err := c.PostMangaWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMangaResponse(rsp)
}

func (c *ClientWithResponses) PostMangaWithResponse(ctx context.Context, params *PostMangaParams, body PostMangaJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMangaResponse, error) {
	rsp, err := c.PostManga(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMangaResponse(rsp)
}

// GetMangaDraftsWithResponse request returning *GetMangaDraftsResponse
func (c *ClientWithResponses) GetMangaDraftsWithResponse(ctx context.Context, params *GetMangaDraftsParams, reqEditors ...RequestEditorFn) (*GetMangaDraftsResponse, error) {
	rsp, err := c.GetMangaDrafts(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaDraftsResponse(rsp)
}

// GetMangaIdDraftWithResponse request returning *GetMangaIdDraftResponse
func (c *ClientWithResponses) GetMangaIdDraftWithResponse(ctx context.Context, id openapi_types.UUID, params *GetMangaIdDraftParams, reqEditors ...RequestEditorFn) (*GetMangaIdDraftResponse, error) {
	rsp, err := c.GetMangaIdDraft(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaIdDraftResponse(rsp)
}

// CommitMangaDraftWithBodyWithResponse request with arbitrary body returning *CommitMangaDraftResponse
func (c *ClientWithResponses) CommitMangaDraftWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitMangaDraftResponse, error) {
	rsp, err := c.CommitMangaDraftWithBody(ctx, id, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitMangaDraftResponse(rsp)
}

func (c *ClientWithResponses) CommitMangaDraftWithResponse(ctx context.Context, id openapi_types.UUID, body CommitMangaDraftJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitMangaDraftResponse, error) {
	rsp, err := c.CommitMangaDraft(ctx, id, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitMangaDraftResponse(rsp)
}

// GetMangaRandomWithResponse request returning *GetMangaRandomResponse
func (c *ClientWithResponses) GetMangaRandomWithResponse(ctx context.Context, params *GetMangaRandomParams, reqEditors ...RequestEditorFn) (*GetMangaRandomResponse, error) {
	rsp, err := c.GetMangaRandom(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaRandomResponse(rsp)
}

// GetMangaChapterReadmarkers2WithResponse request returning *GetMangaChapterReadmarkers2Response
func (c *ClientWithResponses) GetMangaChapterReadmarkers2WithResponse(ctx context.Context, params *GetMangaChapterReadmarkers2Params, reqEditors ...RequestEditorFn) (*GetMangaChapterReadmarkers2Response, error) {
	rsp, err := c.GetMangaChapterReadmarkers2(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaChapterReadmarkers2Response(rsp)
}

// GetMangaStatusWithResponse request returning *GetMangaStatusResponse
func (c *ClientWithResponses) GetMangaStatusWithResponse(ctx context.Context, params *GetMangaStatusParams, reqEditors ...RequestEditorFn) (*GetMangaStatusResponse, error) {
	rsp, err := c.GetMangaStatus(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaStatusResponse(rsp)
}

// GetMangaTagWithResponse request returning *GetMangaTagResponse
func (c *ClientWithResponses) GetMangaTagWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMangaTagResponse, error) {
	rsp, err := c.GetMangaTag(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaTagResponse(rsp)
}

// DeleteMangaIdWithResponse request returning *DeleteMangaIdResponse
func (c *ClientWithResponses) DeleteMangaIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteMangaIdResponse, error) {
	rsp, err := c.DeleteMangaId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMangaIdResponse(rsp)
}

// GetMangaIdWithResponse request returning *GetMangaIdResponse
func (c *ClientWithResponses) GetMangaIdWithResponse(ctx context.Context, id openapi_types.UUID, params *GetMangaIdParams, reqEditors ...RequestEditorFn) (*GetMangaIdResponse, error) {
	rsp, err := c.GetMangaId(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaIdResponse(rsp)
}

// PutMangaIdWithBodyWithResponse request with arbitrary body returning *PutMangaIdResponse
func (c *ClientWithResponses) PutMangaIdWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PutMangaIdParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutMangaIdResponse, error) {
	rsp, err := c.PutMangaIdWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutMangaIdResponse(rsp)
}

func (c *ClientWithResponses) PutMangaIdWithResponse(ctx context.Context, id openapi_types.UUID, params *PutMangaIdParams, body PutMangaIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PutMangaIdResponse, error) {
	rsp, err := c.PutMangaId(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutMangaIdResponse(rsp)
}

// GetMangaAggregateWithResponse request returning *GetMangaAggregateResponse
func (c *ClientWithResponses) GetMangaAggregateWithResponse(ctx context.Context, id openapi_types.UUID, params *GetMangaAggregateParams, reqEditors ...RequestEditorFn) (*GetMangaAggregateResponse, error) {
	rsp, err := c.GetMangaAggregate(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaAggregateResponse(rsp)
}

// GetMangaIdFeedWithResponse request returning *GetMangaIdFeedResponse
func (c *ClientWithResponses) GetMangaIdFeedWithResponse(ctx context.Context, id openapi_types.UUID, params *GetMangaIdFeedParams, reqEditors ...RequestEditorFn) (*GetMangaIdFeedResponse, error) {
	rsp, err := c.GetMangaIdFeed(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaIdFeedResponse(rsp)
}

// DeleteMangaIdFollowWithResponse request returning *DeleteMangaIdFollowResponse
func (c *ClientWithResponses) DeleteMangaIdFollowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteMangaIdFollowResponse, error) {
	rsp, err := c.DeleteMangaIdFollow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMangaIdFollowResponse(rsp)
}

// PostMangaIdFollowWithResponse request returning *PostMangaIdFollowResponse
func (c *ClientWithResponses) PostMangaIdFollowWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostMangaIdFollowResponse, error) {
	rsp, err := c.PostMangaIdFollow(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMangaIdFollowResponse(rsp)
}

// DeleteMangaIdListListIdWithResponse request returning *DeleteMangaIdListListIdResponse
func (c *ClientWithResponses) DeleteMangaIdListListIdWithResponse(ctx context.Context, id openapi_types.UUID, listId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteMangaIdListListIdResponse, error) {
	rsp, err := c.DeleteMangaIdListListId(ctx, id, listId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMangaIdListListIdResponse(rsp)
}

// PostMangaIdListListIdWithResponse request returning *PostMangaIdListListIdResponse
func (c *ClientWithResponses) PostMangaIdListListIdWithResponse(ctx context.Context, id openapi_types.UUID, listId openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostMangaIdListListIdResponse, error) {
	rsp, err := c.PostMangaIdListListId(ctx, id, listId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMangaIdListListIdResponse(rsp)
}

// GetMangaChapterReadmarkersWithResponse request returning *GetMangaChapterReadmarkersResponse
func (c *ClientWithResponses) GetMangaChapterReadmarkersWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetMangaChapterReadmarkersResponse, error) {
	rsp, err := c.GetMangaChapterReadmarkers(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaChapterReadmarkersResponse(rsp)
}

// PostMangaChapterReadmarkersWithBodyWithResponse request with arbitrary body returning *PostMangaChapterReadmarkersResponse
func (c *ClientWithResponses) PostMangaChapterReadmarkersWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PostMangaChapterReadmarkersParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMangaChapterReadmarkersResponse, error) {
	rsp, err := c.PostMangaChapterReadmarkersWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMangaChapterReadmarkersResponse(rsp)
}

func (c *ClientWithResponses) PostMangaChapterReadmarkersWithResponse(ctx context.Context, id openapi_types.UUID, params *PostMangaChapterReadmarkersParams, body PostMangaChapterReadmarkersJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMangaChapterReadmarkersResponse, error) {
	rsp, err := c.PostMangaChapterReadmarkers(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMangaChapterReadmarkersResponse(rsp)
}

// GetMangaIdStatusWithResponse request returning *GetMangaIdStatusResponse
func (c *ClientWithResponses) GetMangaIdStatusWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetMangaIdStatusResponse, error) {
	rsp, err := c.GetMangaIdStatus(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaIdStatusResponse(rsp)
}

// PostMangaIdStatusWithBodyWithResponse request with arbitrary body returning *PostMangaIdStatusResponse
func (c *ClientWithResponses) PostMangaIdStatusWithBodyWithResponse(ctx context.Context, id openapi_types.UUID, params *PostMangaIdStatusParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMangaIdStatusResponse, error) {
	rsp, err := c.PostMangaIdStatusWithBody(ctx, id, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMangaIdStatusResponse(rsp)
}

func (c *ClientWithResponses) PostMangaIdStatusWithResponse(ctx context.Context, id openapi_types.UUID, params *PostMangaIdStatusParams, body PostMangaIdStatusJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMangaIdStatusResponse, error) {
	rsp, err := c.PostMangaIdStatus(ctx, id, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMangaIdStatusResponse(rsp)
}

// GetMangaRelationWithResponse request returning *GetMangaRelationResponse
func (c *ClientWithResponses) GetMangaRelationWithResponse(ctx context.Context, mangaId openapi_types.UUID, params *GetMangaRelationParams, reqEditors ...RequestEditorFn) (*GetMangaRelationResponse, error) {
	rsp, err := c.GetMangaRelation(ctx, mangaId, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMangaRelationResponse(rsp)
}

// PostMangaRelationWithBodyWithResponse request with arbitrary body returning *PostMangaRelationResponse
func (c *ClientWithResponses) PostMangaRelationWithBodyWithResponse(ctx context.Context, mangaId openapi_types.UUID, params *PostMangaRelationParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostMangaRelationResponse, error) {
	rsp, err := c.PostMangaRelationWithBody(ctx, mangaId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMangaRelationResponse(rsp)
}

func (c *ClientWithResponses) PostMangaRelationWithResponse(ctx context.Context, mangaId openapi_types.UUID, params *PostMangaRelationParams, body PostMangaRelationJSONRequestBody, reqEditors ...RequestEditorFn) (*PostMangaRelationResponse, error) {
	rsp, err := c.PostMangaRelation(ctx, mangaId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostMangaRelationResponse(rsp)
}

// DeleteMangaRelationIdWithResponse request returning *DeleteMangaRelationIdResponse
func (c *ClientWithResponses) DeleteMangaRelationIdWithResponse(ctx context.Context, mangaId openapi_types.UUID, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteMangaRelationIdResponse, error) {
	rsp, err := c.DeleteMangaRelationId(ctx, mangaId, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMangaRelationIdResponse(rsp)
}

// GetPingWithResponse request returning *GetPingResponse
func (c *ClientWithResponses) GetPingWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetPingResponse, error) {
	rsp, err := c.GetPing(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPingResponse(rsp)
}

// GetRatingWithResponse request returning *GetRatingResponse
func (c *ClientWithResponses) GetRatingWithResponse(ctx context.Context, params *GetRatingParams, reqEditors ...RequestEditorFn) (*GetRatingResponse, error) {
	rsp, err := c.GetRating(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetRatingResponse(rsp)
}

// DeleteRatingMangaIdWithResponse request returning *DeleteRatingMangaIdResponse
func (c *ClientWithResponses) DeleteRatingMangaIdWithResponse(ctx context.Context, mangaId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteRatingMangaIdResponse, error) {
	rsp, err := c.DeleteRatingMangaId(ctx, mangaId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRatingMangaIdResponse(rsp)
}

// PostRatingMangaIdWithBodyWithResponse request with arbitrary body returning *PostRatingMangaIdResponse
func (c *ClientWithResponses) PostRatingMangaIdWithBodyWithResponse(ctx context.Context, mangaId openapi_types.UUID, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostRatingMangaIdResponse, error) {
	rsp, err := c.PostRatingMangaIdWithBody(ctx, mangaId, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRatingMangaIdResponse(rsp)
}

func (c *ClientWithResponses) PostRatingMangaIdWithResponse(ctx context.Context, mangaId openapi_types.UUID, body PostRatingMangaIdJSONRequestBody, reqEditors ...RequestEditorFn) (*PostRatingMangaIdResponse, error) {
	rsp, err := c.PostRatingMangaId(ctx, mangaId, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRatingMangaIdResponse(rsp)
}

// GetReportsWithResponse request returning *GetReportsResponse
func (c *ClientWithResponses) GetReportsWithResponse(ctx context.Context, params *GetReportsParams, reqEditors ...RequestEditorFn) (*GetReportsResponse, error) {
	rsp, err := c.GetReports(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportsResponse(rsp)
}

// PostReportWithBodyWithResponse request with arbitrary body returning *PostReportResponse
func (c *ClientWithResponses) PostReportWithBodyWithResponse(ctx context.Context, params *PostReportParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostReportResponse, error) {
	rsp, err := c.PostReportWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReportResponse(rsp)
}

func (c *ClientWithResponses) PostReportWithResponse(ctx context.Context, params *PostReportParams, body PostReportJSONRequestBody, reqEditors ...RequestEditorFn) (*PostReportResponse, error) {
	rsp, err := c.PostReport(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostReportResponse(rsp)
}

// GetReportReasonsByCategoryWithResponse request returning *GetReportReasonsByCategoryResponse
func (c *ClientWithResponses) GetReportReasonsByCategoryWithResponse(ctx context.Context, category string, reqEditors ...RequestEditorFn) (*GetReportReasonsByCategoryResponse, error) {
	rsp, err := c.GetReportReasonsByCategory(ctx, category, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReportReasonsByCategoryResponse(rsp)
}

// GetSettingsWithResponse request returning *GetSettingsResponse
func (c *ClientWithResponses) GetSettingsWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSettingsResponse, error) {
	rsp, err := c.GetSettings(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsResponse(rsp)
}

// PostSettingsWithBodyWithResponse request with arbitrary body returning *PostSettingsResponse
func (c *ClientWithResponses) PostSettingsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSettingsResponse, error) {
	rsp, err := c.PostSettingsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSettingsResponse(rsp)
}

func (c *ClientWithResponses) PostSettingsWithResponse(ctx context.Context, body PostSettingsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSettingsResponse, error) {
	rsp, err := c.PostSettings(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSettingsResponse(rsp)
}

// GetSettingsTemplateWithResponse request returning *GetSettingsTemplateResponse
func (c *ClientWithResponses) GetSettingsTemplateWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetSettingsTemplateResponse, error) {
	rsp, err := c.GetSettingsTemplate(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsTemplateResponse(rsp)
}

// PostSettingsTemplateWithBodyWithResponse request with arbitrary body returning *PostSettingsTemplateResponse
func (c *ClientWithResponses) PostSettingsTemplateWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostSettingsTemplateResponse, error) {
	rsp, err := c.PostSettingsTemplateWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSettingsTemplateResponse(rsp)
}

func (c *ClientWithResponses) PostSettingsTemplateWithResponse(ctx context.Context, body PostSettingsTemplateJSONRequestBody, reqEditors ...RequestEditorFn) (*PostSettingsTemplateResponse, error) {
	rsp, err := c.PostSettingsTemplate(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSettingsTemplateResponse(rsp)
}

// GetSettingsTemplateVersionWithResponse request returning *GetSettingsTemplateVersionResponse
func (c *ClientWithResponses) GetSettingsTemplateVersionWithResponse(ctx context.Context, version openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetSettingsTemplateVersionResponse, error) {
	rsp, err := c.GetSettingsTemplateVersion(ctx, version, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetSettingsTemplateVersionResponse(rsp)
}

// GetStatisticsChaptersWithResponse request returning *GetStatisticsChaptersResponse
func (c *ClientWithResponses) GetStatisticsChaptersWithResponse(ctx context.Context, params *GetStatisticsChaptersParams, reqEditors ...RequestEditorFn) (*GetStatisticsChaptersResponse, error) {
	rsp, err := c.GetStatisticsChapters(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatisticsChaptersResponse(rsp)
}

// GetStatisticsChapterUuidWithResponse request returning *GetStatisticsChapterUuidResponse
func (c *ClientWithResponses) GetStatisticsChapterUuidWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetStatisticsChapterUuidResponse, error) {
	rsp, err := c.GetStatisticsChapterUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatisticsChapterUuidResponse(rsp)
}

// GetStatisticsGroupsWithResponse request returning *GetStatisticsGroupsResponse
func (c *ClientWithResponses) GetStatisticsGroupsWithResponse(ctx context.Context, params *GetStatisticsGroupsParams, reqEditors ...RequestEditorFn) (*GetStatisticsGroupsResponse, error) {
	rsp, err := c.GetStatisticsGroups(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatisticsGroupsResponse(rsp)
}

// GetStatisticsGroupUuidWithResponse request returning *GetStatisticsGroupUuidResponse
func (c *ClientWithResponses) GetStatisticsGroupUuidWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetStatisticsGroupUuidResponse, error) {
	rsp, err := c.GetStatisticsGroupUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatisticsGroupUuidResponse(rsp)
}

// GetStatisticsMangaWithResponse request returning *GetStatisticsMangaResponse
func (c *ClientWithResponses) GetStatisticsMangaWithResponse(ctx context.Context, params *GetStatisticsMangaParams, reqEditors ...RequestEditorFn) (*GetStatisticsMangaResponse, error) {
	rsp, err := c.GetStatisticsManga(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatisticsMangaResponse(rsp)
}

// GetStatisticsMangaUuidWithResponse request returning *GetStatisticsMangaUuidResponse
func (c *ClientWithResponses) GetStatisticsMangaUuidWithResponse(ctx context.Context, uuid openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetStatisticsMangaUuidResponse, error) {
	rsp, err := c.GetStatisticsMangaUuid(ctx, uuid, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetStatisticsMangaUuidResponse(rsp)
}

// GetUploadSessionWithResponse request returning *GetUploadSessionResponse
func (c *ClientWithResponses) GetUploadSessionWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUploadSessionResponse, error) {
	rsp, err := c.GetUploadSession(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUploadSessionResponse(rsp)
}

// BeginUploadSessionWithBodyWithResponse request with arbitrary body returning *BeginUploadSessionResponse
func (c *ClientWithResponses) BeginUploadSessionWithBodyWithResponse(ctx context.Context, params *BeginUploadSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BeginUploadSessionResponse, error) {
	rsp, err := c.BeginUploadSessionWithBody(ctx, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBeginUploadSessionResponse(rsp)
}

func (c *ClientWithResponses) BeginUploadSessionWithResponse(ctx context.Context, params *BeginUploadSessionParams, body BeginUploadSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*BeginUploadSessionResponse, error) {
	rsp, err := c.BeginUploadSession(ctx, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBeginUploadSessionResponse(rsp)
}

// BeginEditSessionWithBodyWithResponse request with arbitrary body returning *BeginEditSessionResponse
func (c *ClientWithResponses) BeginEditSessionWithBodyWithResponse(ctx context.Context, chapterId openapi_types.UUID, params *BeginEditSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*BeginEditSessionResponse, error) {
	rsp, err := c.BeginEditSessionWithBody(ctx, chapterId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBeginEditSessionResponse(rsp)
}

func (c *ClientWithResponses) BeginEditSessionWithResponse(ctx context.Context, chapterId openapi_types.UUID, params *BeginEditSessionParams, body BeginEditSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*BeginEditSessionResponse, error) {
	rsp, err := c.BeginEditSession(ctx, chapterId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseBeginEditSessionResponse(rsp)
}

// UploadCheckApprovalRequiredWithBodyWithResponse request with arbitrary body returning *UploadCheckApprovalRequiredResponse
func (c *ClientWithResponses) UploadCheckApprovalRequiredWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*UploadCheckApprovalRequiredResponse, error) {
	rsp, err := c.UploadCheckApprovalRequiredWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCheckApprovalRequiredResponse(rsp)
}

func (c *ClientWithResponses) UploadCheckApprovalRequiredWithResponse(ctx context.Context, body UploadCheckApprovalRequiredJSONRequestBody, reqEditors ...RequestEditorFn) (*UploadCheckApprovalRequiredResponse, error) {
	rsp, err := c.UploadCheckApprovalRequired(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseUploadCheckApprovalRequiredResponse(rsp)
}

// AbandonUploadSessionWithResponse request returning *AbandonUploadSessionResponse
func (c *ClientWithResponses) AbandonUploadSessionWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, reqEditors ...RequestEditorFn) (*AbandonUploadSessionResponse, error) {
	rsp, err := c.AbandonUploadSession(ctx, uploadSessionId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseAbandonUploadSessionResponse(rsp)
}

// PutUploadSessionFileWithBodyWithResponse request with arbitrary body returning *PutUploadSessionFileResponse
func (c *ClientWithResponses) PutUploadSessionFileWithBodyWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, params *PutUploadSessionFileParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutUploadSessionFileResponse, error) {
	rsp, err := c.PutUploadSessionFileWithBody(ctx, uploadSessionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutUploadSessionFileResponse(rsp)
}

// DeleteUploadedSessionFilesWithBodyWithResponse request with arbitrary body returning *DeleteUploadedSessionFilesResponse
func (c *ClientWithResponses) DeleteUploadedSessionFilesWithBodyWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, params *DeleteUploadedSessionFilesParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*DeleteUploadedSessionFilesResponse, error) {
	rsp, err := c.DeleteUploadedSessionFilesWithBody(ctx, uploadSessionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUploadedSessionFilesResponse(rsp)
}

func (c *ClientWithResponses) DeleteUploadedSessionFilesWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, params *DeleteUploadedSessionFilesParams, body DeleteUploadedSessionFilesJSONRequestBody, reqEditors ...RequestEditorFn) (*DeleteUploadedSessionFilesResponse, error) {
	rsp, err := c.DeleteUploadedSessionFiles(ctx, uploadSessionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUploadedSessionFilesResponse(rsp)
}

// CommitUploadSessionWithBodyWithResponse request with arbitrary body returning *CommitUploadSessionResponse
func (c *ClientWithResponses) CommitUploadSessionWithBodyWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, params *CommitUploadSessionParams, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*CommitUploadSessionResponse, error) {
	rsp, err := c.CommitUploadSessionWithBody(ctx, uploadSessionId, params, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitUploadSessionResponse(rsp)
}

func (c *ClientWithResponses) CommitUploadSessionWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, params *CommitUploadSessionParams, body CommitUploadSessionJSONRequestBody, reqEditors ...RequestEditorFn) (*CommitUploadSessionResponse, error) {
	rsp, err := c.CommitUploadSession(ctx, uploadSessionId, params, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseCommitUploadSessionResponse(rsp)
}

// DeleteUploadedSessionFileWithResponse request returning *DeleteUploadedSessionFileResponse
func (c *ClientWithResponses) DeleteUploadedSessionFileWithResponse(ctx context.Context, uploadSessionId openapi_types.UUID, uploadSessionFileId openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteUploadedSessionFileResponse, error) {
	rsp, err := c.DeleteUploadedSessionFile(ctx, uploadSessionId, uploadSessionFileId, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUploadedSessionFileResponse(rsp)
}

// GetUserWithResponse request returning *GetUserResponse
func (c *ClientWithResponses) GetUserWithResponse(ctx context.Context, params *GetUserParams, reqEditors ...RequestEditorFn) (*GetUserResponse, error) {
	rsp, err := c.GetUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserResponse(rsp)
}

// PostUserDeleteCodeWithResponse request returning *PostUserDeleteCodeResponse
func (c *ClientWithResponses) PostUserDeleteCodeWithResponse(ctx context.Context, code openapi_types.UUID, reqEditors ...RequestEditorFn) (*PostUserDeleteCodeResponse, error) {
	rsp, err := c.PostUserDeleteCode(ctx, code, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostUserDeleteCodeResponse(rsp)
}

// GetUserFollowsGroupWithResponse request returning *GetUserFollowsGroupResponse
func (c *ClientWithResponses) GetUserFollowsGroupWithResponse(ctx context.Context, params *GetUserFollowsGroupParams, reqEditors ...RequestEditorFn) (*GetUserFollowsGroupResponse, error) {
	rsp, err := c.GetUserFollowsGroup(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFollowsGroupResponse(rsp)
}

// GetUserFollowsGroupIdWithResponse request returning *GetUserFollowsGroupIdResponse
func (c *ClientWithResponses) GetUserFollowsGroupIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserFollowsGroupIdResponse, error) {
	rsp, err := c.GetUserFollowsGroupId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFollowsGroupIdResponse(rsp)
}

// GetUserFollowsListWithResponse request returning *GetUserFollowsListResponse
func (c *ClientWithResponses) GetUserFollowsListWithResponse(ctx context.Context, params *GetUserFollowsListParams, reqEditors ...RequestEditorFn) (*GetUserFollowsListResponse, error) {
	rsp, err := c.GetUserFollowsList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFollowsListResponse(rsp)
}

// GetUserFollowsListIdWithResponse request returning *GetUserFollowsListIdResponse
func (c *ClientWithResponses) GetUserFollowsListIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserFollowsListIdResponse, error) {
	rsp, err := c.GetUserFollowsListId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFollowsListIdResponse(rsp)
}

// GetUserFollowsMangaWithResponse request returning *GetUserFollowsMangaResponse
func (c *ClientWithResponses) GetUserFollowsMangaWithResponse(ctx context.Context, params *GetUserFollowsMangaParams, reqEditors ...RequestEditorFn) (*GetUserFollowsMangaResponse, error) {
	rsp, err := c.GetUserFollowsManga(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFollowsMangaResponse(rsp)
}

// GetUserFollowsMangaFeedWithResponse request returning *GetUserFollowsMangaFeedResponse
func (c *ClientWithResponses) GetUserFollowsMangaFeedWithResponse(ctx context.Context, params *GetUserFollowsMangaFeedParams, reqEditors ...RequestEditorFn) (*GetUserFollowsMangaFeedResponse, error) {
	rsp, err := c.GetUserFollowsMangaFeed(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFollowsMangaFeedResponse(rsp)
}

// GetUserFollowsMangaIdWithResponse request returning *GetUserFollowsMangaIdResponse
func (c *ClientWithResponses) GetUserFollowsMangaIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserFollowsMangaIdResponse, error) {
	rsp, err := c.GetUserFollowsMangaId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFollowsMangaIdResponse(rsp)
}

// GetUserFollowsUserWithResponse request returning *GetUserFollowsUserResponse
func (c *ClientWithResponses) GetUserFollowsUserWithResponse(ctx context.Context, params *GetUserFollowsUserParams, reqEditors ...RequestEditorFn) (*GetUserFollowsUserResponse, error) {
	rsp, err := c.GetUserFollowsUser(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFollowsUserResponse(rsp)
}

// GetUserFollowsUserIdWithResponse request returning *GetUserFollowsUserIdResponse
func (c *ClientWithResponses) GetUserFollowsUserIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserFollowsUserIdResponse, error) {
	rsp, err := c.GetUserFollowsUserId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserFollowsUserIdResponse(rsp)
}

// GetReadingHistoryWithResponse request returning *GetReadingHistoryResponse
func (c *ClientWithResponses) GetReadingHistoryWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetReadingHistoryResponse, error) {
	rsp, err := c.GetReadingHistory(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetReadingHistoryResponse(rsp)
}

// GetUserListWithResponse request returning *GetUserListResponse
func (c *ClientWithResponses) GetUserListWithResponse(ctx context.Context, params *GetUserListParams, reqEditors ...RequestEditorFn) (*GetUserListResponse, error) {
	rsp, err := c.GetUserList(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserListResponse(rsp)
}

// GetUserMeWithResponse request returning *GetUserMeResponse
func (c *ClientWithResponses) GetUserMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetUserMeResponse, error) {
	rsp, err := c.GetUserMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserMeResponse(rsp)
}

// DeleteUserIdWithResponse request returning *DeleteUserIdResponse
func (c *ClientWithResponses) DeleteUserIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*DeleteUserIdResponse, error) {
	rsp, err := c.DeleteUserId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteUserIdResponse(rsp)
}

// GetUserIdWithResponse request returning *GetUserIdResponse
func (c *ClientWithResponses) GetUserIdWithResponse(ctx context.Context, id openapi_types.UUID, reqEditors ...RequestEditorFn) (*GetUserIdResponse, error) {
	rsp, err := c.GetUserId(ctx, id, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserIdResponse(rsp)
}

// GetUserIdListWithResponse request returning *GetUserIdListResponse
func (c *ClientWithResponses) GetUserIdListWithResponse(ctx context.Context, id openapi_types.UUID, params *GetUserIdListParams, reqEditors ...RequestEditorFn) (*GetUserIdListResponse, error) {
	rsp, err := c.GetUserIdList(ctx, id, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUserIdListResponse(rsp)
}

// ParseGetAtHomeServerChapterIdResponse parses an HTTP response from a GetAtHomeServerChapterIdWithResponse call
func ParseGetAtHomeServerChapterIdResponse(rsp *http.Response) (*GetAtHomeServerChapterIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAtHomeServerChapterIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			// BaseUrl The base URL to construct final image URLs from.
			// The URL returned is valid for the requested chapter only, and for a duration of 15 minutes from the time of the response.
			BaseUrl *string `json:"baseUrl,omitempty"`
			Chapter *struct {
				Data      *[]string `json:"data,omitempty"`
				DataSaver *[]string `json:"dataSaver,omitempty"`
				Hash      *string   `json:"hash,omitempty"`
			} `json:"chapter,omitempty"`
			Result *string `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAuthCheckResponse parses an HTTP response from a GetAuthCheckWithResponse call
func ParseGetAuthCheckResponse(rsp *http.Response) (*GetAuthCheckResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthCheckResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CheckResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostAuthLoginResponse parses an HTTP response from a PostAuthLoginWithResponse call
func ParsePostAuthLoginResponse(rsp *http.Response) (*PostAuthLoginResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthLoginResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LoginResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParsePostAuthLogoutResponse parses an HTTP response from a PostAuthLogoutWithResponse call
func ParsePostAuthLogoutResponse(rsp *http.Response) (*PostAuthLogoutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthLogoutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest LogoutResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 503:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON503 = &dest

	}

	return response, nil
}

// ParsePostAuthRefreshResponse parses an HTTP response from a PostAuthRefreshWithResponse call
func ParsePostAuthRefreshResponse(rsp *http.Response) (*PostAuthRefreshResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthRefreshResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest RefreshResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetAuthorResponse parses an HTTP response from a GetAuthorWithResponse call
func ParseGetAuthorResponse(rsp *http.Response) (*GetAuthorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePostAuthorResponse parses an HTTP response from a PostAuthorWithResponse call
func ParsePostAuthorResponse(rsp *http.Response) (*PostAuthorResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostAuthorResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteAuthorIdResponse parses an HTTP response from a DeleteAuthorIdWithResponse call
func ParseDeleteAuthorIdResponse(rsp *http.Response) (*DeleteAuthorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteAuthorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetAuthorIdResponse parses an HTTP response from a GetAuthorIdWithResponse call
func ParseGetAuthorIdResponse(rsp *http.Response) (*GetAuthorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetAuthorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutAuthorIdResponse parses an HTTP response from a PutAuthorIdWithResponse call
func ParsePutAuthorIdResponse(rsp *http.Response) (*PutAuthorIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutAuthorIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest AuthorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostCaptchaSolveResponse parses an HTTP response from a PostCaptchaSolveWithResponse call
func ParsePostCaptchaSolveResponse(rsp *http.Response) (*PostCaptchaSolveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCaptchaSolveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *PostCaptchaSolve200Result `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseGetChapterResponse parses an HTTP response from a GetChapterWithResponse call
func ParseGetChapterResponse(rsp *http.Response) (*GetChapterResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChapterResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChapterList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteChapterIdResponse parses an HTTP response from a DeleteChapterIdWithResponse call
func ParseDeleteChapterIdResponse(rsp *http.Response) (*DeleteChapterIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteChapterIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetChapterIdResponse parses an HTTP response from a GetChapterIdWithResponse call
func ParseGetChapterIdResponse(rsp *http.Response) (*GetChapterIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetChapterIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChapterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutChapterIdResponse parses an HTTP response from a PutChapterIdWithResponse call
func ParsePutChapterIdResponse(rsp *http.Response) (*PutChapterIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutChapterIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChapterResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetListApiclientsResponse parses an HTTP response from a GetListApiclientsWithResponse call
func ParseGetListApiclientsResponse(rsp *http.Response) (*GetListApiclientsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListApiclientsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiClientList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostCreateApiclientResponse parses an HTTP response from a PostCreateApiclientWithResponse call
func ParsePostCreateApiclientResponse(rsp *http.Response) (*PostCreateApiclientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostCreateApiclientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiClientResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteApiclientResponse parses an HTTP response from a DeleteApiclientWithResponse call
func ParseDeleteApiclientResponse(rsp *http.Response) (*DeleteApiclientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteApiclientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *string `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetApiclientResponse parses an HTTP response from a GetApiclientWithResponse call
func ParseGetApiclientResponse(rsp *http.Response) (*GetApiclientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiclientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiClientResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostEditApiclientResponse parses an HTTP response from a PostEditApiclientWithResponse call
func ParsePostEditApiclientResponse(rsp *http.Response) (*PostEditApiclientResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostEditApiclientResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ApiClientResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetApiclientSecretResponse parses an HTTP response from a GetApiclientSecretWithResponse call
func ParseGetApiclientSecretResponse(rsp *http.Response) (*GetApiclientSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetApiclientSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *string                      `json:"data,omitempty"`
			Result *GetApiclientSecret200Result `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePostRegenerateApiclientSecretResponse parses an HTTP response from a PostRegenerateApiclientSecretWithResponse call
func ParsePostRegenerateApiclientSecretResponse(rsp *http.Response) (*PostRegenerateApiclientSecretResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRegenerateApiclientSecretResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *string                                 `json:"data,omitempty"`
			Result *PostRegenerateApiclientSecret200Result `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetCoverResponse parses an HTTP response from a GetCoverWithResponse call
func ParseGetCoverResponse(rsp *http.Response) (*GetCoverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoverList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteCoverResponse parses an HTTP response from a DeleteCoverWithResponse call
func ParseDeleteCoverResponse(rsp *http.Response) (*DeleteCoverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteCoverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetCoverIdResponse parses an HTTP response from a GetCoverIdWithResponse call
func ParseGetCoverIdResponse(rsp *http.Response) (*GetCoverIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetCoverIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoverResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUploadCoverResponse parses an HTTP response from a UploadCoverWithResponse call
func ParseUploadCoverResponse(rsp *http.Response) (*UploadCoverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadCoverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoverResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseEditCoverResponse parses an HTTP response from a EditCoverWithResponse call
func ParseEditCoverResponse(rsp *http.Response) (*EditCoverResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &EditCoverResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CoverResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseForumsThreadCreateResponse parses an HTTP response from a ForumsThreadCreateWithResponse call
func ParseForumsThreadCreateResponse(rsp *http.Response) (*ForumsThreadCreateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &ForumsThreadCreateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ForumsThreadResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSearchGroupResponse parses an HTTP response from a GetSearchGroupWithResponse call
func ParseGetSearchGroupResponse(rsp *http.Response) (*GetSearchGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScanlationGroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePostGroupResponse parses an HTTP response from a PostGroupWithResponse call
func ParsePostGroupResponse(rsp *http.Response) (*PostGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScanlationGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteGroupIdResponse parses an HTTP response from a DeleteGroupIdWithResponse call
func ParseDeleteGroupIdResponse(rsp *http.Response) (*DeleteGroupIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetGroupIdResponse parses an HTTP response from a GetGroupIdWithResponse call
func ParseGetGroupIdResponse(rsp *http.Response) (*GetGroupIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetGroupIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScanlationGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutGroupIdResponse parses an HTTP response from a PutGroupIdWithResponse call
func ParsePutGroupIdResponse(rsp *http.Response) (*PutGroupIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutGroupIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScanlationGroupResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteGroupIdFollowResponse parses an HTTP response from a DeleteGroupIdFollowWithResponse call
func ParseDeleteGroupIdFollowResponse(rsp *http.Response) (*DeleteGroupIdFollowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteGroupIdFollowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostGroupIdFollowResponse parses an HTTP response from a PostGroupIdFollowWithResponse call
func ParsePostGroupIdFollowResponse(rsp *http.Response) (*PostGroupIdFollowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostGroupIdFollowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostLegacyMappingResponse parses an HTTP response from a PostLegacyMappingWithResponse call
func ParsePostLegacyMappingResponse(rsp *http.Response) (*PostLegacyMappingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLegacyMappingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MappingIdResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostListResponse parses an HTTP response from a PostListWithResponse call
func ParsePostListResponse(rsp *http.Response) (*PostListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteListIdResponse parses an HTTP response from a DeleteListIdWithResponse call
func ParseDeleteListIdResponse(rsp *http.Response) (*DeleteListIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteListIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetListIdResponse parses an HTTP response from a GetListIdWithResponse call
func ParseGetListIdResponse(rsp *http.Response) (*GetListIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutListIdResponse parses an HTTP response from a PutListIdWithResponse call
func ParsePutListIdResponse(rsp *http.Response) (*PutListIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutListIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetListIdFeedResponse parses an HTTP response from a GetListIdFeedWithResponse call
func ParseGetListIdFeedResponse(rsp *http.Response) (*GetListIdFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetListIdFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChapterList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseUnfollowListIdResponse parses an HTTP response from a UnfollowListIdWithResponse call
func ParseUnfollowListIdResponse(rsp *http.Response) (*UnfollowListIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UnfollowListIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *UnfollowListId200Result `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseFollowListIdResponse parses an HTTP response from a FollowListIdWithResponse call
func ParseFollowListIdResponse(rsp *http.Response) (*FollowListIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &FollowListIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *FollowListId200Result `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSearchMangaResponse parses an HTTP response from a GetSearchMangaWithResponse call
func ParseGetSearchMangaResponse(rsp *http.Response) (*GetSearchMangaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSearchMangaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostMangaResponse parses an HTTP response from a PostMangaWithResponse call
func ParsePostMangaResponse(rsp *http.Response) (*PostMangaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMangaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetMangaDraftsResponse parses an HTTP response from a GetMangaDraftsWithResponse call
func ParseGetMangaDraftsResponse(rsp *http.Response) (*GetMangaDraftsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaDraftsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMangaIdDraftResponse parses an HTTP response from a GetMangaIdDraftWithResponse call
func ParseGetMangaIdDraftResponse(rsp *http.Response) (*GetMangaIdDraftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaIdDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseCommitMangaDraftResponse parses an HTTP response from a CommitMangaDraftWithResponse call
func ParseCommitMangaDraftResponse(rsp *http.Response) (*CommitMangaDraftResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitMangaDraftResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest MangaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMangaRandomResponse parses an HTTP response from a GetMangaRandomWithResponse call
func ParseGetMangaRandomResponse(rsp *http.Response) (*GetMangaRandomResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaRandomResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaChapterReadmarkers2Response parses an HTTP response from a GetMangaChapterReadmarkers2WithResponse call
func ParseGetMangaChapterReadmarkers2Response(rsp *http.Response) (*GetMangaChapterReadmarkers2Response, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaChapterReadmarkers2Response{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *GetMangaChapterReadmarkers2_200_Data `json:"data,omitempty"`
			Result *GetMangaChapterReadmarkers2200Result `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaStatusResponse parses an HTTP response from a GetMangaStatusWithResponse call
func ParseGetMangaStatusResponse(rsp *http.Response) (*GetMangaStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result   *string                               `json:"result,omitempty"`
			Statuses *map[string]GetMangaStatus200Statuses `json:"statuses,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaTagResponse parses an HTTP response from a GetMangaTagWithResponse call
func ParseGetMangaTagResponse(rsp *http.Response) (*GetMangaTagResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaTagResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TagResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteMangaIdResponse parses an HTTP response from a DeleteMangaIdWithResponse call
func ParseDeleteMangaIdResponse(rsp *http.Response) (*DeleteMangaIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMangaIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMangaIdResponse parses an HTTP response from a GetMangaIdWithResponse call
func ParseGetMangaIdResponse(rsp *http.Response) (*GetMangaIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutMangaIdResponse parses an HTTP response from a PutMangaIdWithResponse call
func ParsePutMangaIdResponse(rsp *http.Response) (*PutMangaIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutMangaIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMangaAggregateResponse parses an HTTP response from a GetMangaAggregateWithResponse call
func ParseGetMangaAggregateResponse(rsp *http.Response) (*GetMangaAggregateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaAggregateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result  *string `json:"result,omitempty"`
			Volumes *map[string]struct {
				Chapters *map[string]struct {
					Chapter *string               `json:"chapter,omitempty"`
					Count   *int                  `json:"count,omitempty"`
					Id      *openapi_types.UUID   `json:"id,omitempty"`
					Others  *[]openapi_types.UUID `json:"others,omitempty"`
				} `json:"chapters,omitempty"`
				Count  *int    `json:"count,omitempty"`
				Volume *string `json:"volume,omitempty"`
			} `json:"volumes,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaIdFeedResponse parses an HTTP response from a GetMangaIdFeedWithResponse call
func ParseGetMangaIdFeedResponse(rsp *http.Response) (*GetMangaIdFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaIdFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChapterList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteMangaIdFollowResponse parses an HTTP response from a DeleteMangaIdFollowWithResponse call
func ParseDeleteMangaIdFollowResponse(rsp *http.Response) (*DeleteMangaIdFollowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMangaIdFollowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostMangaIdFollowResponse parses an HTTP response from a PostMangaIdFollowWithResponse call
func ParsePostMangaIdFollowResponse(rsp *http.Response) (*PostMangaIdFollowResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMangaIdFollowResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteMangaIdListListIdResponse parses an HTTP response from a DeleteMangaIdListListIdWithResponse call
func ParseDeleteMangaIdListListIdResponse(rsp *http.Response) (*DeleteMangaIdListListIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMangaIdListListIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostMangaIdListListIdResponse parses an HTTP response from a PostMangaIdListListIdWithResponse call
func ParsePostMangaIdListListIdResponse(rsp *http.Response) (*PostMangaIdListListIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMangaIdListListIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMangaChapterReadmarkersResponse parses an HTTP response from a GetMangaChapterReadmarkersWithResponse call
func ParseGetMangaChapterReadmarkersResponse(rsp *http.Response) (*GetMangaChapterReadmarkersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaChapterReadmarkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]openapi_types.UUID                `json:"data,omitempty"`
			Result *GetMangaChapterReadmarkers200Result `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostMangaChapterReadmarkersResponse parses an HTTP response from a PostMangaChapterReadmarkersWithResponse call
func ParsePostMangaChapterReadmarkersResponse(rsp *http.Response) (*PostMangaChapterReadmarkersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMangaChapterReadmarkersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *PostMangaChapterReadmarkers200Result `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetMangaIdStatusResponse parses an HTTP response from a GetMangaIdStatusWithResponse call
func ParseGetMangaIdStatusResponse(rsp *http.Response) (*GetMangaIdStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaIdStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *string                    `json:"result,omitempty"`
			Status *GetMangaIdStatus200Status `json:"status,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostMangaIdStatusResponse parses an HTTP response from a PostMangaIdStatusWithResponse call
func ParsePostMangaIdStatusResponse(rsp *http.Response) (*PostMangaIdStatusResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMangaIdStatusResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMangaRelationResponse parses an HTTP response from a GetMangaRelationWithResponse call
func ParseGetMangaRelationResponse(rsp *http.Response) (*GetMangaRelationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMangaRelationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaRelationList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParsePostMangaRelationResponse parses an HTTP response from a PostMangaRelationWithResponse call
func ParsePostMangaRelationResponse(rsp *http.Response) (*PostMangaRelationResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostMangaRelationResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaRelationResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseDeleteMangaRelationIdResponse parses an HTTP response from a DeleteMangaRelationIdWithResponse call
func ParseDeleteMangaRelationIdResponse(rsp *http.Response) (*DeleteMangaRelationIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMangaRelationIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPingResponse parses an HTTP response from a GetPingWithResponse call
func ParseGetPingResponse(rsp *http.Response) (*GetPingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetRatingResponse parses an HTTP response from a GetRatingWithResponse call
func ParseGetRatingResponse(rsp *http.Response) (*GetRatingResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetRatingResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ratings *map[string]struct {
				CreatedAt *time.Time `json:"createdAt,omitempty"`
				Rating    *int       `json:"rating,omitempty"`
			} `json:"ratings,omitempty"`
			Result *string `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteRatingMangaIdResponse parses an HTTP response from a DeleteRatingMangaIdWithResponse call
func ParseDeleteRatingMangaIdResponse(rsp *http.Response) (*DeleteRatingMangaIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRatingMangaIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostRatingMangaIdResponse parses an HTTP response from a PostRatingMangaIdWithResponse call
func ParsePostRatingMangaIdResponse(rsp *http.Response) (*PostRatingMangaIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRatingMangaIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReportsResponse parses an HTTP response from a GetReportsWithResponse call
func ParseGetReportsResponse(rsp *http.Response) (*GetReportsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ReportListResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParsePostReportResponse parses an HTTP response from a PostReportWithResponse call
func ParsePostReportResponse(rsp *http.Response) (*PostReportResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostReportResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReportReasonsByCategoryResponse parses an HTTP response from a GetReportReasonsByCategoryWithResponse call
func ParseGetReportReasonsByCategoryResponse(rsp *http.Response) (*GetReportReasonsByCategoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReportReasonsByCategoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data *[]struct {
				Attributes *struct {
					Category        *GetReportReasonsByCategory200DataAttributesCategory `json:"category,omitempty"`
					DetailsRequired *bool                                                `json:"detailsRequired,omitempty"`
					Reason          *LocalizedString                                     `json:"reason,omitempty"`
					Version         *int                                                 `json:"version,omitempty"`
				} `json:"attributes,omitempty"`
				Id   *openapi_types.UUID `json:"id,omitempty"`
				Type *string             `json:"type,omitempty"`
			} `json:"data,omitempty"`
			Limit    *int    `json:"limit,omitempty"`
			Offset   *int    `json:"offset,omitempty"`
			Response *string `json:"response,omitempty"`
			Result   *string `json:"result,omitempty"`
			Total    *int    `json:"total,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSettingsResponse parses an HTTP response from a GetSettingsWithResponse call
func ParseGetSettingsResponse(rsp *http.Response) (*GetSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *string `json:"result,omitempty"`

			// Settings Settings that were validated by linked template
			Settings *map[string]interface{} `json:"settings,omitempty"`

			// Template Settings template UUID
			Template  *openapi_types.UUID `json:"template,omitempty"`
			UpdatedAt *time.Time          `json:"updatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostSettingsResponse parses an HTTP response from a PostSettingsWithResponse call
func ParsePostSettingsResponse(rsp *http.Response) (*PostSettingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSettingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result *string `json:"result,omitempty"`

			// Settings Settings that were validated against the linked template
			Settings *map[string]interface{} `json:"settings,omitempty"`

			// Template Settings template UUID
			Template  *openapi_types.UUID `json:"template,omitempty"`
			UpdatedAt *time.Time          `json:"updatedAt,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetSettingsTemplateResponse parses an HTTP response from a GetSettingsTemplateWithResponse call
func ParseGetSettingsTemplateResponse(rsp *http.Response) (*GetSettingsTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostSettingsTemplateResponse parses an HTTP response from a PostSettingsTemplateWithResponse call
func ParsePostSettingsTemplateResponse(rsp *http.Response) (*PostSettingsTemplateResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSettingsTemplateResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	}

	return response, nil
}

// ParseGetSettingsTemplateVersionResponse parses an HTTP response from a GetSettingsTemplateVersionWithResponse call
func ParseGetSettingsTemplateVersionResponse(rsp *http.Response) (*GetSettingsTemplateVersionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetSettingsTemplateVersionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest map[string]interface{}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetStatisticsChaptersResponse parses an HTTP response from a GetStatisticsChaptersWithResponse call
func ParseGetStatisticsChaptersResponse(rsp *http.Response) (*GetStatisticsChaptersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatisticsChaptersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result     *string `json:"result,omitempty"`
			Statistics *map[string]struct {
				// Comments Comments-related statistics of an entity.
				// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
				Comments *StatisticsDetailsComments `json:"comments"`
			} `json:"statistics,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStatisticsChapterUuidResponse parses an HTTP response from a GetStatisticsChapterUuidWithResponse call
func ParseGetStatisticsChapterUuidResponse(rsp *http.Response) (*GetStatisticsChapterUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatisticsChapterUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result     *string `json:"result,omitempty"`
			Statistics *map[string]struct {
				// Comments Comments-related statistics of an entity.
				// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
				Comments *StatisticsDetailsComments `json:"comments"`
			} `json:"statistics,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStatisticsGroupsResponse parses an HTTP response from a GetStatisticsGroupsWithResponse call
func ParseGetStatisticsGroupsResponse(rsp *http.Response) (*GetStatisticsGroupsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatisticsGroupsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result     *string `json:"result,omitempty"`
			Statistics *map[string]struct {
				// Comments Comments-related statistics of an entity.
				// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
				Comments *StatisticsDetailsComments `json:"comments"`
			} `json:"statistics,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStatisticsGroupUuidResponse parses an HTTP response from a GetStatisticsGroupUuidWithResponse call
func ParseGetStatisticsGroupUuidResponse(rsp *http.Response) (*GetStatisticsGroupUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatisticsGroupUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result     *string `json:"result,omitempty"`
			Statistics *map[string]struct {
				// Comments Comments-related statistics of an entity.
				// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
				Comments *StatisticsDetailsComments `json:"comments"`
			} `json:"statistics,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStatisticsMangaResponse parses an HTTP response from a GetStatisticsMangaWithResponse call
func ParseGetStatisticsMangaResponse(rsp *http.Response) (*GetStatisticsMangaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatisticsMangaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result     *string `json:"result,omitempty"`
			Statistics *map[string]struct {
				// Comments Comments-related statistics of an entity.
				// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
				Comments *StatisticsDetailsComments `json:"comments"`
				Follows  *int                       `json:"follows,omitempty"`
				Rating   *struct {
					// Average Will be nullable if no ratings has been done
					Average *float32 `json:"average"`

					// Bayesian Average weighted on all the Manga population
					Bayesian *float32 `json:"bayesian,omitempty"`
				} `json:"rating,omitempty"`
			} `json:"statistics,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetStatisticsMangaUuidResponse parses an HTTP response from a GetStatisticsMangaUuidWithResponse call
func ParseGetStatisticsMangaUuidResponse(rsp *http.Response) (*GetStatisticsMangaUuidResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetStatisticsMangaUuidResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Result     *string `json:"result,omitempty"`
			Statistics *map[string]struct {
				// Comments Comments-related statistics of an entity.
				// If it is `null`, the entity doesn't have a backing comments thread, and therefore has no comments yet.
				Comments *StatisticsDetailsComments `json:"comments"`
				Follows  *int                       `json:"follows,omitempty"`
				Rating   *struct {
					// Average Will be nullable if no ratings has been given
					Average *float32 `json:"average"`

					// Bayesian Average weighted on all the Manga population
					Bayesian     *float32 `json:"bayesian,omitempty"`
					Distribution *struct {
						N1  *int `json:"1,omitempty"`
						N10 *int `json:"10,omitempty"`
						N2  *int `json:"2,omitempty"`
						N3  *int `json:"3,omitempty"`
						N4  *int `json:"4,omitempty"`
						N5  *int `json:"5,omitempty"`
						N6  *int `json:"6,omitempty"`
						N7  *int `json:"7,omitempty"`
						N8  *int `json:"8,omitempty"`
						N9  *int `json:"9,omitempty"`
					} `json:"distribution,omitempty"`
				} `json:"rating,omitempty"`
				UnavailableChapterCount *int `json:"unavailableChapterCount,omitempty"`
			} `json:"statistics,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUploadSessionResponse parses an HTTP response from a GetUploadSessionWithResponse call
func ParseGetUploadSessionResponse(rsp *http.Response) (*GetUploadSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUploadSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseBeginUploadSessionResponse parses an HTTP response from a BeginUploadSessionWithResponse call
func ParseBeginUploadSessionResponse(rsp *http.Response) (*BeginUploadSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BeginUploadSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseBeginEditSessionResponse parses an HTTP response from a BeginEditSessionWithResponse call
func ParseBeginEditSessionResponse(rsp *http.Response) (*BeginEditSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &BeginEditSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UploadSession
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseUploadCheckApprovalRequiredResponse parses an HTTP response from a UploadCheckApprovalRequiredWithResponse call
func ParseUploadCheckApprovalRequiredResponse(rsp *http.Response) (*UploadCheckApprovalRequiredResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &UploadCheckApprovalRequiredResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			RequiresApproval *bool                                 `json:"requiresApproval,omitempty"`
			Result           *UploadCheckApprovalRequired200Result `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseAbandonUploadSessionResponse parses an HTTP response from a AbandonUploadSessionWithResponse call
func ParseAbandonUploadSessionResponse(rsp *http.Response) (*AbandonUploadSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &AbandonUploadSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePutUploadSessionFileResponse parses an HTTP response from a PutUploadSessionFileWithResponse call
func ParsePutUploadSessionFileResponse(rsp *http.Response) (*PutUploadSessionFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutUploadSessionFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Data   *[]UploadSessionFile           `json:"data,omitempty"`
			Errors *[]Error                       `json:"errors,omitempty"`
			Result *PutUploadSessionFile200Result `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	}

	return response, nil
}

// ParseDeleteUploadedSessionFilesResponse parses an HTTP response from a DeleteUploadedSessionFilesWithResponse call
func ParseDeleteUploadedSessionFilesResponse(rsp *http.Response) (*DeleteUploadedSessionFilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUploadedSessionFilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseCommitUploadSessionResponse parses an HTTP response from a CommitUploadSessionWithResponse call
func ParseCommitUploadSessionResponse(rsp *http.Response) (*CommitUploadSessionResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &CommitUploadSessionResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Chapter
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUploadedSessionFileResponse parses an HTTP response from a DeleteUploadedSessionFileWithResponse call
func ParseDeleteUploadedSessionFileResponse(rsp *http.Response) (*DeleteUploadedSessionFileResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUploadedSessionFileResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserResponse parses an HTTP response from a GetUserWithResponse call
func ParseGetUserResponse(rsp *http.Response) (*GetUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParsePostUserDeleteCodeResponse parses an HTTP response from a PostUserDeleteCodeWithResponse call
func ParsePostUserDeleteCodeResponse(rsp *http.Response) (*PostUserDeleteCodeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostUserDeleteCodeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFollowsGroupResponse parses an HTTP response from a GetUserFollowsGroupWithResponse call
func ParseGetUserFollowsGroupResponse(rsp *http.Response) (*GetUserFollowsGroupResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFollowsGroupResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ScanlationGroupList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFollowsGroupIdResponse parses an HTTP response from a GetUserFollowsGroupIdWithResponse call
func ParseGetUserFollowsGroupIdResponse(rsp *http.Response) (*GetUserFollowsGroupIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFollowsGroupIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserFollowsListResponse parses an HTTP response from a GetUserFollowsListWithResponse call
func ParseGetUserFollowsListResponse(rsp *http.Response) (*GetUserFollowsListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFollowsListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomListList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFollowsListIdResponse parses an HTTP response from a GetUserFollowsListIdWithResponse call
func ParseGetUserFollowsListIdResponse(rsp *http.Response) (*GetUserFollowsListIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFollowsListIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserFollowsMangaResponse parses an HTTP response from a GetUserFollowsMangaWithResponse call
func ParseGetUserFollowsMangaResponse(rsp *http.Response) (*GetUserFollowsMangaResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFollowsMangaResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest MangaList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFollowsMangaFeedResponse parses an HTTP response from a GetUserFollowsMangaFeedWithResponse call
func ParseGetUserFollowsMangaFeedResponse(rsp *http.Response) (*GetUserFollowsMangaFeedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFollowsMangaFeedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest ChapterList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserFollowsMangaIdResponse parses an HTTP response from a GetUserFollowsMangaIdWithResponse call
func ParseGetUserFollowsMangaIdResponse(rsp *http.Response) (*GetUserFollowsMangaIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFollowsMangaIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserFollowsUserResponse parses an HTTP response from a GetUserFollowsUserWithResponse call
func ParseGetUserFollowsUserResponse(rsp *http.Response) (*GetUserFollowsUserResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFollowsUserResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserFollowsUserIdResponse parses an HTTP response from a GetUserFollowsUserIdWithResponse call
func ParseGetUserFollowsUserIdResponse(rsp *http.Response) (*GetUserFollowsUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserFollowsUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetReadingHistoryResponse parses an HTTP response from a GetReadingHistoryWithResponse call
func ParseGetReadingHistoryResponse(rsp *http.Response) (*GetReadingHistoryResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetReadingHistoryResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			Ratings *[]struct {
				ChapterId *string    `json:"chapterId,omitempty"`
				ReadDate  *time.Time `json:"readDate,omitempty"`
			} `json:"ratings,omitempty"`
			Result *string `json:"result,omitempty"`
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 403:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON403 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest ErrorResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUserListResponse parses an HTTP response from a GetUserListWithResponse call
func ParseGetUserListResponse(rsp *http.Response) (*GetUserListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomListList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserMeResponse parses an HTTP response from a GetUserMeWithResponse call
func ParseGetUserMeResponse(rsp *http.Response) (*GetUserMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseDeleteUserIdResponse parses an HTTP response from a DeleteUserIdWithResponse call
func ParseDeleteUserIdResponse(rsp *http.Response) (*DeleteUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Response
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserIdResponse parses an HTTP response from a GetUserIdWithResponse call
func ParseGetUserIdResponse(rsp *http.Response) (*GetUserIdResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserIdResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest UserResponse
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// ParseGetUserIdListResponse parses an HTTP response from a GetUserIdListWithResponse call
func ParseGetUserIdListResponse(rsp *http.Response) (*GetUserIdListResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUserIdListResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest CustomListList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON200 = &dest

	}

	return response, nil
}

// Base64 encoded, gzipped, json marshaled Swagger object
var swaggerSpec = []string{

	"H4sIAAAAAAAC/+y9eXfbtpow/lXw4/ScG98rWtQuec6cjJs0t/5N0+TEzp23Y+lNIRKU0FCEBgC9NPV3",
	"fw8WruKmzZYd/dM6FInlwYNnX74ZNlksiY98zoyzbwaz52gB5Z/nS/zGw8jn4h9LSpaIcozkT5BziqcB",
	"V//6gSLXODP+rRkP1dTjNKNBzuNPHhoGdsSHLqELyI0zIwiwYzQMfr9ExpnBOMX+TLxGkQc5Jj6b46Wc",
	"CnO0qJzzU+IrMYoeFlIK7+N/fzOQHyyMs2sDLvEXW+10srII8T7mnngUAyR6i0z/QDYXg+ZtdAVuNkWQ",
	"I+dcgnRltw5iNsVLsXTx+wLe/YL8GZ8bZ+1ev2H4gefBqVgJpwHKgRa644j60FPruJAgrvwIs3Ob4xuU",
	"WNGUEA9BX/zqwwXKXeuSEhd7+b8xDnkKwBT9b4AYR+KM4XJJyY38kyIBPPU04CT6ZZKzzGDplEDuBlEW",
	"Qg37eCGmbUWjYJ+jGaL5Z5k4rrJTfSNPTuK+42BxRND7mDhbF3oMNTLHve2BhtBPfNhpN8QWw3/2GqVH",
	"Ex7AElEmVpwL2vrAE+eIKXLEkHJt8WSTHNBqmJWB9ScH55CXDNwq4bTZDsKvJuve8F8wy1s05LA2iYon",
	"yqFPHl7gJJ5HG2gYxHUZKviNIrYkPkMKgi4MPEFabeJ5yJagzCWwTL6W/IJ8zXuTEw69vInzLpWEUBkI",
	"PyXWmg/G2tDL3zbyOeb35VuuQemjdeZtJuBzQrdijnKEQ+aMaovlXFG9UwigMn44xWRG4XJ+X7XwX4gN",
	"Pfwnci4jCEwJERQwCSuKjVWquoRcsEXjzPi/c86X7PVZs/nqejy+NSf/GI9PT17Lgcbj0+XiVfOvH07y",
	"oF3Ot13o/0judrEUF/pTcjcen9p24Vpc6HMMdzQbx3A8Pv1jWTgbXsAZ+ky9WnR4gTzi/0jI112sTg42",
	"JeQrE/Ag5csslFN8uMA2WeBdrCgcS65nUbKWG0R3M98NolWTYZv8CzuI7GRCbJMbMVg5sJf4Dt/sYj45",
	"0Hh86iNeOBn7iqa7mEuMU74tHiym3k4OTo1UcXL8FothNpxPf10xx06k5oZxi6YMK+l3g6XmLewW4elO",
	"UFYONB6fvrL9v2yyOCkExT0JeDDddA+3t7fj8akeoxToK5yxQsGQ72ykXTwX5vmS2eNBcrwj+zmyn4Ng",
	"P0e+sRbfWDGvTLK8pMSiIn/PN6ccGcWRURwZxZFRHC6jOGoi++coeebumGkUspRdGLuVhfBFWbpj2BRC",
	"bksbdwS0vRi40yvM2cOPaIZ9gRqXiIV3cw3ldGcumZV1FK3189Ij0NlstTNKgowZPWuBT/rg+ikfnPjn",
	"Kr+HdxdqqJa1ivcL6M/g1rNkgKcGbYSbycIwDZ8cKL6Zw6Um9Js6NPQQB+zRsPUmS10aISSyQGoYdya6",
	"g4ulp0Ch/16FUTjLmdHqnbaM2DUvLemGIOZnzSYjC2SGv5gB9U6558QHeHadHvZ6omBp2NOu7Y6gbSLU",
	"bpndYd814dRyzXZr2hpMoQWnAzcBYRv6CkZf5MDGwySBgLkTdDsjBHtwZKJRu212u07LnI7slgk7qNXq",
	"DadOr5eYQI21Cj6g/t0wOIU+8yBHzi/QnwVwhiT9MhpGIHFS4VzuStodp9e2upbZgYOB2XVdZA67jmP2",
	"nanb7o1Qp40SyBQwxR8i4tNqGDfEC4QAbLRCXDSg1XOQZfVNxx32za6LWubIaVtmp93vd+FgaLdsOx40",
	"PMuHh/iOlMZ4xNcocZuHNdz95V6mFAplfOTGW+QTjhiAwA6BP4cceNj/ygAnAPog/B4wElAbnaapTa/V",
	"3lyGwuyzD28g1h/nBZIs4SzHt2+8IYHPAXEBRdARXwPpcGLAJWILmIX7MfKkwWUw9TCbFwAsHLLgZ42t",
	"mbCMXo1zysPnb0lgXUPzz8m39sMrM/zr5PUP69vnk7ejknzWFqHDC1Hpz1u90eWmbP3SWwpdvib/TdyZ",
	"GuzlX2oHq3diV/icwqvER+Ox8637YF5bZmsyHjvmq2vLbIu//urIZydXr8Lf/mpfW2ZncnJ2bZk98SD6",
	"IxcRDgEZY8RY4wyyApx63DAS17aYC0yKsSi0ZEHP++BKVlhjUZ9UnJnx0PiWL1Y+TOIZdqDYhHLCS9Js",
	"ktApPp5PCDrvIf2K6I+Q2/PK6w79e32MyXPRSHLhMDGeMcmeW/z7Z5+qNyYFpCMcY4cifPZIV1azt7lW",
	"jyOGN1MArymamgt8h5w8OF23Gu1GZ5K3Lf2TpK9qlHC7BYMk3gz81Xez4z4k8Ujd2DIpai2O8Nia3EEQ",
	"7vVZ/3oUfgUZ1aGVkYdtTB8Jsrq57SNU+CQlRJSSejpfmUkkDZhK+T5xlK9eWX9dt8yR4P9/P3k1Hp+O",
	"x84/Tl7Lg32tjzW9kH+FnHRlj2/myP5aDGHMzgM+FyCyBXIViOOILrC0BKTvSiURrM9sKNGkqO7gqcNI",
	"bjHvKMhigfmKySeXhkQCaQ2cU+9qfeUD1cJ3Wmch4jFygIeZVF3UKoBeBniHhRbjCBF59ySoZ1ny9ZAi",
	"lcCwptGH3Gxp8hEDHLLBR6zvC6QVuR0KDkUA2llORyVXcLGHfi3y2HnEhh6qNc6OIr82UhYzECsCaq3Y",
	"/yqVbg0YHQJrFfsuUp30VNFYkwxIi/w08sddaDPyCrwoXSaCTBHYthRUQojtw0WTXl/RBjYRRvJlkVfy",
	"KvwjI4wk5sgTRSTtu4wszP+UBuZVEkl8Dm3+0wLieoHk61JNBzOb0JoJbz4sSXjD1H4zh76P6i0UU/sS",
	"Uc1Cq+PjoT+DnyVlZpkja7WH1faqs/G4OR5rF7AcTJF5FQayGI+br6T+85c2YCF68kr8NucLbzx+jZ3/",
	"EEf913jcjBzXzdehE/vk9avxuHny+uSHtaJI9FRvkQfvK6jux1evJOIp9Lu2zNHk5O3Ja/305L9PXr+6",
	"Cl9pyZ+lFa07Ofk5ekt821Pf/tW3Tt4X/XB58rqApO8wnqEi5q2aZZZFfOXfrTw6EDBOFvkMYA05Lhrl",
	"kIU5ucgvQvKuEOdimJRCrEywK0T5+kIBZniKPcEEksmYFN+oKD55d+y6O6kQqaL34mDy9H4in1+hWlKp",
	"/e0NJAoQjQg2k7VvS3b7pSDKFz1fFIByQiky+y+F0C7kyfgOviihMg2jUihuKV6mAPiIprDV9efs8ic5",
	"UK6sh+54TTGP15UIsVNYaiBg+agSmWaLd6r2ULS54tOTQKzP5tQ0Na1pKL2molWXHc07QoMFu5pTBJ1q",
	"FCyTGNK/UbT0MGLSab9qF7uaI+AHiymiyqEv3wWMABdSgH3A5wi4cmWAy6UBinhA/WQER+rCZbelcGB1",
	"UuzocAEUDkySszUAtG3EGJ56CEAOfleydLOpflaCtIPuTgmdNdUArHmGnd9zYw5CkSQ+MPVJ/ollt7D5",
	"JS4nXQnsyD38nKVkg/0LXXh5TonG8KHMj70yeO78M7xunB4KNchVNQQydqtVwKRaZbW7KfvqMM9WxhDN",
	"KbXRT3/ZquK40RImSTiITRbtvvhurkm8Bef6ivy8cVyK2DyfdsZ280rMfchsqRyxZiTgO9tbeurkyDlz",
	"vw9FuE3VIDnAAWtASkYthdJ7HQeaD5wyjQd6/EoMUn/5ORlD2R1EgWFXKw7P9Dyb2GcLfPS/SjbEPiGG",
	"+Af/V3Qbm8lWTT5SYvH5J8g1GQxhzaArkIwFsxli0mQksJRwbAvwLgn1VV5VrgrXWM8xsCaQMfuF2F+L",
	"vHseZDwRzVttM4eM/6uupV+8zhHTzjfkJCaqvCMyHrGM0xQdcIzEhOIZ9qGXdJrnG6VsebHeokV0Ssmz",
	"nZPAlzGo4q8/iNEw/iAMYfEAYfHLpIazYaXSlSP9hwJnpgvMVW2r0BiXKnk1aZQJs7HzarH0kBqG+DOi",
	"WKkNfRt5nnw6x/KbXJYAZ/Uv8hXMvU+RDL0mfu7I/XSPYI4D9jcEtYjpISj5QMFB5alvWSJYRCcTKfm1",
	"QtDkR0UBaGEMnD7hHCzOkiEVqiYHXS8UrnQd6UA4+eoOFP33UQD4S9HxY8gUoUfIt7eWNcKBDl3m+BLO",
	"VUP4iIBTBb3zUmUzhnC0EuITe06J9EYtIPa/ME6o0JygI7iQ88Wl0iw/hQw5X+QKlrL6oCduH3ZQ9IFD",
	"gj+wAIH4AS7QF5dC355jSU/YHFLkfAl8LG6MfBINssT+F+K6Yk5PRh/zeND4SezNXVLEEMWCQoZAsYlH",
	"qCTf6V+2q86XewQ1KF346oYUT31cSPkgnSEeiqQxDsUEKBxhV4QoQr4XR5BSkKo6zcLIyuO90tJRjJjV",
	"pLboKEpCITPvbWMIXsHrx7MF5++ieLsFSLcfzZJyzDjbzmOjShxuOcghqZ3bKZb7Vh33owBuYjpYUryA",
	"9D4KgMweeuVeHlPJ3KdauDa2b6oU7lztW8A7NcpoNBo1UoOuqxFWE/KtCfiTEO4ygr1cYn+myoRvrsLo",
	"QQ5afZFr/IKdKoiFACmDVpnK4qEZtO8vnHwp0ke3F84aFy5r9E0m1c3CYCA4q7mpKkVAv/Yjce7XdMpg",
	"JzfMf8VnVnxC4W5W91l/f3LhZTurvsE1dYwQS16WfpGFUg4oPyEXUeTb6Ke7JfQFKU+1iEhT6+hlgMK3",
	"AZE/quTuuOkCkOQPIwYIlUkVqdSJiOcJ7bTI+aV3UbbA1cPKeTuq6L3mXuR3TSWP1ttOkR+ndDOZStsl",
	"O0mIcOttJSwfsMYmGqslJpRPdc3trVTdKNufzDGgG+CdzAcBkPL1trjJfsI11tlQpIiutxu5vPV2EifE",
	"hMqPEapSmuA2NrxsGcdj1W6TJtRNdh1KD/u7cAXGzJKNfUJLsglWCvQCVH5cbzsSH2WNC1Zk4Cjcll5k",
	"nf3khPavt7GYNABJGurtzkOy7kXDWCChUa+5v8KY6eRGKWLzYpFggRgrci4eYGxG0uKqlzdJQSi123zW",
	"Ll65Cle6hvgX7W6dWBn10eoa1QJyF5gQ+isUljSGXrggRtIIRwBmAC6XHkZOA8j8FOwzoOZjACaF5QJV",
	"MhuXVk/bQU7eHZI/AElugPiuAYjv3QNp4vQ5wC64JwGAFAHiA6hfVFojgL4TPUoqVAIlv2PzrlYxijWH",
	"T2lY5WBcSMo3VY7VCAesGSuGU65gZZlFFkDbpMZyiL18q5+a5aIq6DfcyC3EXBnBoG2jJdexFm7Aou5i",
	"FDHi5XcXW9ltua6s3qkX3l3z2CSID0WfrM3VqtXKHFDlAnT3oYJl81XmK9a/4pmhDviur+hopeCrkXZW",
	"vPU878+vcLFb58/aOaW7zdNfJ+MU3f2CbeSzonA9l9iCUCUdGlsFRRYsKALdE2bAeiVRi9ns2Ex25ktI",
	"liWui22cIpvJoiyZVNq0lHg5J4HnAEHbZQghuLj8AIZ9qwWcgCoNS/yCXe2TOgNhngPyT2/xV7xEDoYy",
	"yUH8q3lx+eGL+Pzf3urPmdGIK5oaH7tvjXTa+Mf87N2PrxP5ux9fH3wG70Z9krCLi9B2k9rl9YtpFFPZ",
	"apKcn+V4UMn4GdLHXjTtQ7WLeX4fZFIZd9ieMm6z1PQRyMh+SEFFVm/epa+mDTuItsvKiC/JH5YHrWqg",
	"bhckkAPPnYQLrCPol6pNHHLMOLbZW6W5vyGLRdg3PlvWWf1iapsXYNG3gLiyGrXcw+nYv3AB5gAz8Lu4",
	"Cb83ZOKmNm05BDH/bxzM4Q0CEEyh/RX7M2Dr0XW2Z0OawPgcUeQSisAcMuCT+K17xE/Hft613jq5VeeZ",
	"SuPbW3QH3qXSW8P1yjrWakt/Y9G6TsGVfH5ne4GDmBwI+5hj6IXvqCLeZIl8lshubYDbObbnAmZapwHT",
	"e0ACCtg9ExdX7TaiQHHVSrUBeQfkSBfFCbXETebTxjtBMVxVzi3k4WnlA+PUaOQRw3ApSVQsxK8cZLyC",
	"s2309is4O2BdvTLq4QrOCoBSpoZvFxk4C20lcRSaDGA0GiHYGsYM+VTSjjlaoFyrUciu9xM6lgZRubB8",
	"BWc7st8V5E49W+aXhEwO4JTsKa/5ZWSJTYNv1UIryIiy0BL/y5zIPhdLD/pfOPmi0+cdSpZLbbn9Er8f",
	"BztWB0tmpCW9jISwtLr23A2WlhWtT2VSA21Eb7KUQbUE+BK6B0uJRGXtz6LlrWnHx0xVYy0sNovZW6RO",
	"sODnj5TYiBXax3aSTFgEmHIikXr1HfbQztBBDLYHlPjiikXWxwu5pzobL8MPMefPsMCVLX68xH8mlbRY",
	"DlngBbrKd9XFkd7vymqiqm4mqeABwT4kFVkQjnaUVFUGjzzwse2q6orvD1hAKYiGSsKL5ZfTzWxs1eOz",
	"btXodPmOXZw0q6peK97Ygf78mb2wcqsRXApgtp16HIJr/zpxaq154TYM2QHF/P5SLE3t4EcEqbrycr2S",
	"g6lH0QBzzpeqixT2XZIwxSYq2xgsWC4J5f+ZLEpkhGKzEelWjEPXBRzBxYqFNn4JM6FpQ8d0KUJR0Bx0",
	"pA7rIrFvMMezufm/AfSEBqd6L/1/Y3/sS93UIXYg9VDtqpdK5vnHCwCZVtopns058MntKbiQD7AvdO9b",
	"eA8gWFKywAwBToCPbpAMLvVnCGDeANDjcxLM5uAWgVvseQD5DoI3YgJOgEqt8e6BTzh27wH078EC/kHC",
	"IU7FEv8NnEtnv2wbFTAElsTD9r346TODMyR0WKkVI3qDbcQAXiitXcUIQN9GoZrrEs8jt9ifnY19E/xG",
	"AvD3v7//fHn1978LFdvBHASs6JdshBsLw3UkjOXwUBX0EzuT6rQOsk0M+eb8118/iEFpIE5MRsctIXbi",
	"xRNfDEqBNh0C6DtNGUa9ZOq8EBNnfB8CGXIJNY4XSMUo+ypUyJdrYMSX/1KnGCzF0sSa7Tmyv6qIRGUF",
	"Bi4lCzUKJ/L/GvaX+g4AzFiA5Bou1L6nyMPoBsm/XRLI8CSWeltgiUalBljKbB49s3h6Hb58yu/45FUz",
	"+c8TsYoZ4rKeGAnsOdAFEb17ZfVIpb+IS3D+8cJIsAGjd9pqn1qSmC6RD5fYODM6p9ZpR3m75vI2NyE3",
	"52SBmkya95vfomYmD7JdpKLBgoLJg79wjDPjn4if85/JAimXwJvwCzkuhQvEpa37OmtweUeojQBDkkz7",
	"MwXwcPn/KQYEahVMWVsEpgukYhz6DqQO+Pnq6uMlkKGj3W5HHs9/z7GHtLXGvxG0kfjQU++Iw1WfcApd",
	"F9sCA7rdjsSHcCZIEUC+TQIKZ8gRQBfTiourMMYnHEAwF9NrhUvSCUUXOLLnPrah54nz9v/Gxz707/lc",
	"7E66KKEnV/kzuRVkoQGY2OQCsymawxv5lj0nxGtKdykCPuK3hH5VdAJyhY1Tj9hfoy0IEkN8M4KJ2Clr",
	"6C1xHlnhXA/OxMu/C/Xx95DysICisa+PgPjSRKlBEcFcWuCYbJuHxbH9b4Bk7JqmzK44xY+E8m63IyPi",
	"BdNKsSgdPJlVbx4mMUuTuNe2rKiOorJEyjhF5dRt/sGUMBNPkGhCOYUMxR0m2VmzCae2g9zTu/s/W+1O",
	"XOlOQ/Ss1e50e6oPJUeLJaGQ3puqWp7JdShmohOPYtPXxl3LnA76PTTsOz1kT+1Rp227HbfXGsBh3+q6",
	"fWj3nSEcuJ3BaGq1BwPYag0ce2BbI7vXcaxuC50upXJ/1zZde2C3RsPh0LKGnanV60zdLhpCNHVtCyG7",
	"BZ0p6rWHgyHs2z3XtYZOu9frdmHL6fWsNnLDkTrmyHJbvak9nI5aDppajj0cdgedaa/TRt02HI3cUQeh",
	"EWrbQ2vQGYx69rA1tVqu63bbQ+gOLTnSpCG3eamao8u9wml7OrCHbseyh90OhB3Y69jt0dQe2hZqW113",
	"Crtw2kGD3mjYcwb91qjdQtM+7LVdt9/qjU7/WOq9dpDVGzijzgBZrf6oDx0btaHdHvZ7br/t9t0+bPVc",
	"q2Mjt9txRu3RdDhEoxHsTofdYRtZnXCkjtlqDwfdtjUcuqPR0OpPrXZ7OrWHltUXwOn13TZsW47ltAZ9",
	"Z+B22v0u7PdcdwR73ZFjOY4cadIw5lJtM5zRYNif9oeDqd1zOy5qOV2ILAHuHrLQtJcUpIT89JC1nkeo",
	"l2dPFj+Cz59+ETfPJj7jNLA5cIVup2QO8aNiNaeSlcmXw+qQgt7cQC9R5ZGqZE0UcVIZLquuu+R1cUgE",
	"cUGrBxbYD2JmNkeKhGjmH96+0zzp0S5qirsi6lfqKQm0Wuezeb5iXVBdsna1yIxQuyJFfvgvMWLX6q5F",
	"jCqroEZydc6UvxIO3gmBISVkq26wLFgsIL1XfDaXPQqcMcL05mtD8WJj8lDBfsNmtRdvQ8oupICYsNsJ",
	"Ph7bFpX1Md53VfkIsYwmDPi8KeWchBCxelsivA8bDCWaNUmnD1ksA4H8Dloi3xG8TbteZshHFNtAKNGp",
	"ryQTk3gviLrKNplDJp1tmIpXmRQQyA2iFDuIRT418GGJ/Iu3gNlkiVjkFpLDvLpFwCFSFlCy7oxCP/Ag",
	"1b8nV3CP+IkU0FaFpoDPZb8nY0tGWN7eKdlQqgDdH5JoJr9QghZaOQXIGLGxdL3dYj5XklZAqfTZhSkM",
	"ISLG3bhU5ZsIFbywAuqSMI0LS4p01y6FYWlofSRMgiusKppBbIm98zB1RuPvGwU+U1rZylA4JhkrYM7B",
	"ZzUSYjxMGN7JMamN5RyPuBcM/xnR7ClxhGwJpK1ECajt//rxNGkf2DkOpQuflpBM6/FI5o/QAXHpJaNr",
	"tR5v7s++Sh/Ef6Jyih0Vwa1zI0jAN7wS4sv9Hn+y+Gzh+feszuOdwaUyD4Bk/+00HYsAUw39RELauuDX",
	"6VsvkSalMtMOlDRlM/yOxClNnMTkj3gr3xE6xY4j8aWYLOpDqy8wqNIEhcanMJc77wZmrBXKxZB701pW",
	"oq5OS7ebzAYSJaz/+RNoR0Vyhqph0iBUuwHYYeBV4ia1LEsIYqEGeFJgjcEOu56kZt80wLRog/J/yQlW",
	"VKwCwFBFCeMP85sOhb4KyGxDoVeBzyKrAzJ+Lw2gDkLLD+HT/LVgX4WeZUBVQWjyi1Jsb8cqm1ZNojqh",
	"HCZpOzjqoi+QF5V1iGgLoUor1iw+n6EXUpJnzcvVznSh0814+XDfvFyt8dBZ+dPhe6yhy2MEcVWcLI7H",
	"fLP5DSvPjSMDkVbRXgUoqS+1qWdvolr1wT4NcJ/W2hcdqzqKkmNtVIhAeS63l8D+jpiTlg1ljL+ar8pe",
	"XIZMpdZhPVWRcRhvaRVuGMsgjwkHVaj8AriwTFQ68uBnx4MPhE2oSO4K7m/DJbfnsClLf6TtWikfkHqN",
	"ARv6YIqAqhQC0J3YFebePeBzKqOVdCqPsyTY5w0AfcLniMp4J8wEakLHARD8/n9MPab5SfrkfgfqxspX",
	"/PtQfz0FEtvhAgGPzLCtAhJkvvG9ciqoUVSsDgNLSqZw6t2DBaFhbIcsoThFNlQRGoDDrzJcCAEPMRbN",
	"NPbHftqyIAZUpbqgdwoiGECKAKfQ/oqUM3VKQgeHqtaIl5GfVTyVviTsNJJFijwymyEHYBmyBG6h9IoA",
	"hnxHxTDpWGXtJpoGOtFJx5WExOvUyLM26nVeyhN9VsRRB2qwxN+mtIjdQC+Q2KlP+80ceh7yZ6npHopt",
	"BqufrVeMa+X7SY5/eFtyu3Vhl2qH9VmIxDIFcIqQr2/yU5LqeFF2CF+gdg9uIQO3lPgzlfQYvvcvWW5A",
	"31Ed/yffdcitDwgFkuY0AEWuIigyY1IsCeiydZHzVj59QxwEsM+wgxKvhn1aM6JTHMl6PXlIyVHyxoWL",
	"TBDc8ImmuHG8RK6DO3S3e1hQPx0xqCiEAIEOjFQRWDN8g3zl68+ECcqYTSRItCbF7DTPtRxXFH0RNtEQ",
	"dgdrFI3aXK1rFVWBs3tenUqUyVhfiY90q5uqWTZf0KRwSXEB3boqQ8FAN7IFQwaA8d5K9rLx2uMi3Y81",
	"I19pIFmEMZnKIefm/4zH5uRbu9F7+GFzBMp2nnjc2XWiuPPhSVeR6lqSmTqil+U9TCY5BV+37HmyHgT/",
	"+RjUJpxMt8mk+55PW7PeBTygKCwPky/cthKlQS2jYbRyJa7SaX5aLPn9R1mxJzmHHtVqtCb1+WJq5R9V",
	"1ZZzvrNxf7qTxUW9z9Tb2ZjJcIt8GFtbwDhKt73Evp2dICkQvIUcXeEFAmpEFYsW5bIAhVln4LfffvvN",
	"fP/efPv26uefz96/P7u8lPkTeIH+FHri56s3/7DSxb7GY+db98G8tszWZDx2zFfXltkWf/3Vkc9Orl6F",
	"v8kKX53Jydm1ZfbEg+iPH+rzryjF9/vZ8jLE9O9ny1XO74TyUMv/nSnqWPObCPBrfEMRdMRtX+ujVN56",
	"zW9uol5ajxkBkM+ZtmrzkGZak73G9kqsKYoOSGqcxziBFfdICjwJrV5fxZRWX9ON+iYVMv8EftRwT5EZ",
	"SK3XOT3a7A/Btfsm2d4pg23Fzt2ShMq9eXfDdT0KATv6dzPX1ydcJRBX+nfLMWqr/J/9uXirEPpZ+3j1",
	"5rZw8nb2HjW9xr07soyndfOWXXApoERd6IrYhxAPz5dYvcier0sgbxjGIUd5xg0jypQ1GuL0KLnRBdb+",
	"kDXEdW+M6Jf6NopN4593E3QVdfVbQ9WMji5Vz0wpVivpzJvolWuFbm+iHdZV9vYaihaCviwYO52AJLNY",
	"b31wvsTgTXT9oniN6CzLg5JVtGd0g19kXFQIijhA+eExjvLIAGvHGifbieYgcMyK6kYcV+Bz1s0XtcdK",
	"mNBS9rx//FCEr3uI3dhdlYGjWowS9LGQPBYGPq+HRjtnwpNDIVMHcJoy3jg6SjC9V6plAb8rDT4OX92n",
	"clrIcIXq9n2w21BJPTLb750SC0xYl8k3GbIpKtU9o2t0qV7dKTsOCxFtU/jyANm0pnyRDbChas7J5j0g",
	"7JisI4b5HAkNQ5cjTZNiBXIZrvzcKfInJAv8JNWgCKGeJXXec5Dx8WYU3owYlcJbEWFSIckjN6i0AIHs",
	"d/9SYm1VP+UNI22lw3yH8V7Z5jqyROdBRAFnim6wzaOTgz3EyaVXJ9uKqBpmEpcBpHyTlXpqnJpxl7W6",
	"1tWNP60In9nAaPl8YlS2c+SKAz+n+9ZV5TTHMhXrhJ/og1mJP5HMJMF5mt8kVf1A5S8XteJQNEN60lz+",
	"79xwGoZ86KPIHm+jXJp43GCPR6QRR8w5hDiTkPasEWhSiMeleuMFU2ls4PPni7eA+ODjh8urfAUyTeX2",
	"o0yqnIQyeX0HquMi8DheQsqbYp2mVMbW1B7zhijT99L97XI7EaXgNsU+pPcFDXihbva0gTgXC0iVhOBf",
	"6tVcXfPhSIWenH+pq1J27/Oiu35yMN/z9XrC0C6xsS0Cu/Yf13XE7Vq4La3dRZgtBG9XdnBtqiawJeUz",
	"pN7JAAzbxWJfd9WR3XDDShEqnZsi1bEt7GI7hfZXlmksG/i2KkuhWgSfR+MyWeg/anuLZe/gsEswusOM",
	"g3vE/11lyN9i3SllSZH8TXUBCUcKy6yf5pQlV61rr+S7Ohhj87uUZlK4suduCKG4sWp1M8DV8cQvOSNm",
	"czrCRI4w9aaeFXSftzcJ+2NIdChApg9S3il1fxJdmuW1wMSXxSLiHhnifkgRV16C/MAWN9m4OkEN1GFo",
	"chB1AC7S2S4RpPb8nxqlXoQdONMf/eUVpHWJHbA4o/7JYjpXut9vFNnpCUbEdc61E8YI7zLKUyVeIifq",
	"E7+f6FCKPHQDffvlR5RmDv5oPV3DehrDDijylLGiZi9VeYhtGeF+3hqLvOerFGYT7aXV37f6klnnUZGp",
	"G52bvQ2lFyESaGpG6srvjqWBDyFQdq1zLvYwxCf6WB6GVQo0OSw68l1gV1akr2/9XxPxSl0CK6z78RNQ",
	"yy/As+b4meM45FrDR3b/7LJRtxA0mkp/rC1vvFOvP7HUcQig9xXktiTCjxyyezzF9Cm+2+AMxQXy0Aza",
	"980FXC4F1BOuiFWY/yLffa9ffYHMTW/twpGjbqjGWvvma9Eqy/Dkai49MeoFVf18hm+QqiTuA2nzFLvQ",
	"By+DNyMjOHaQz7GLEWXg3+VGf3cgh6eQc4qnAUfs1Ee3F87vwMXIc4BNqJrKYWHZZB/dypiMJ64MVNY8",
	"U2IzuHgbwiBxV9Rv4RXBjFdcDGUcennmnYBxshC7O+zOTvE6D13IOwBOoW06McySPur4YYz7Ne044quj",
	"GecgyoBVHm2jtJrLfk9xvcv6mFGL0cLWiVusAevyMlnxrHs3VGxGuRurBo4IS14wy3uM5OXnw7iO1om1",
	"WWbTRcipqpx14bxDyNlBUEcyqqOXiupoPXrZrGM/gWM/gWM/gaftJ3CsdX+sdX+sdX+sdf9c8oijgtDH",
	"/ij774/yhF0DDkGZaT3e3J991Sgd/xl2S/weNamiHPXY9qGyOF2lC0VB8uKfj+NrzGhuOb7kVeOJtj9E",
	"hhMkaNOKuST0ryYsa09a1CenW2qqV2pYw8cgX8u7oz7vYj8HaGUIHfHPxKaYm7JW/168S9+K77nO1iFf",
	"yaPR8WkjOuoZHVXWYVFvYJU+BqDMYgDEVdw2t7OvevW9TmLcZ6ZZcXnlbc2UW4y8caNdJeV9oOeUq6Pa",
	"uvOsGnHf1igo17u/2mC/IUhVbIlqM00o8ImPCrL57hEs6nubOlRlc8g72EZM+uQ8q8RvUqVjOVdw9khG",
	"QDnVe+IUKXPnv75NqHPqXx8+rWEFDI2bj7Cl5FQlW/rwabsdMQ55ULiXiO35M6JCegRJlj3KjIYxx+Jb",
	"8RD6NvK83MYcRyfDGtQjNEZcPbHHR5rjFH9+ixahC6IKS9icBD6SVf/nJPiDGA3jD8IQFg8QVr8UUJFq",
	"yrdVocv9pzU/Z//Q0bfxfRr6n0U+esHK6nsJ5I3cc0a7knP364WQwtxz8kEoracQH+eQnYf8Th9rrhNC",
	"m90bBqeBrDUDPYbWkHDmkCXM/DVmqj90WJRmLUPPHgPZ/Rks8hMo9vn0vYVLzNeJJcaquUKiZD2AvJpO",
	"AMoI+QI9/CNhvEwFf+ZJFv4MbhVP3u/uP8XCn8EyFFFHr3bhHEsFxHgdom32OkRGqqZDoVva1EN+8la8",
	"xYynPOPv2SkRU7xvxo8IUiHBXE8eVsKfMyZFEB1bDjncly2xdUBtQRVyCyhNF5jzdE/QyW5E3/002TxK",
	"hCUS4SRDvqKUmFIaduG81ehwJGKHTcTYEtnYxXaSitUmYjt1rD4ZNoshBPWVJrqnyux+I9cQCwBbREtA",
	"x8Gq1unHBG2UuliWXIbNP5PcII+p5GDceRJjAJ9DLmRVTsAUgYgHgEXAOJjDGwQgBx6CgmP6SDdL0TVd",
	"Q3My8LQBtaE+m6LwjbHiLmMDSP4DoO9ErywhY0I4ltVeKUU2B3pX4ddJp3ye8Nx6fJr0uBLzd+9ZrkMO",
	"LyXOAlhBCGMCQqHvkEUlK/ykXnu8ilAVtpznbP0+uikPyU05eWrpriJBFQJ1RWto5mEx8twYkvNI09MB",
	"9tK1JTkepAgsIP2KHCDrI0MnU5p8EbrC8iJOlD1IjfkJQUeORFnbqAhye58YtMyFViym7C7KQRUaU9FX",
	"DEzvUzsuNMRK7XAl0mRKiIegvzFq5QSTmQntMQoqU00/rg3LsnqD4bBjdnqDqdkddLrmqNsfmb32qD9A",
	"vRFyu0JLsyxrOhgNhqYzmjpmd4RsEw7dvgmtQWfQ6Q+7rZ4rX2v1pv12y4StQc/sDtyeOWy5U7M3GvTt",
	"4RC1hnbXmDQyIW2NaKUhYFZX+s3oWr32yO5YpuW0e2bXgT0TtnvQdActOOq34HTY6z3Vjh4a9aP0wv3E",
	"wS2bYmKjSM7dYsis1j3ZfV/Ph1UruqQa+uoniJQgCO/l0xSlUkEglVLHJdfxHqWE5DNTZmUXe4KsCbIl",
	"Sd30XpMvFg5THI+SawwSe1JBKMT/MieeDHP1oP+Fky+6HLxDyXKprURf4vfjoJWdcZwkWVA7VbcsPogU",
	"bF+r//1HvKbcaNSG3r8ad2q1Rgj2HLPnor7Z7TpdE06ntun2un233bKGw644nnBMiR2BX2M19aZvd0Zd",
	"2LMHZstpI7Pbb7kmtB1ktoaDdn86Qp2B0zfOEjBff721Ym9jKUIuceXCJddcdH33i0Or93STmyvFC88D",
	"8Q3G/kzfFikBeGQ2Qw74zFKNUFYFDw5nlXf5Cs72aUi7grMtBK0rOCvyA8a7rFdGR1sOn6qOjjrLOWRg",
	"ipAP1Fqd02M8dlhcp0iMbuSLzeKOFEdbx4f92Hrx5GiUfqSZ1Y3yCQinq9LYijGshj70+MWOy3H44EMV",
	"oOdpIbwSpVVFoEaW8esQ+lKhewHvfkH+jM+Ns05f+i6T/6wUyXUuwP6myBP7n2tsxjFz6TDKJVUbnKTf",
	"Cc5mFM2gkohKRcDz6M1a/PKpqxDN1qpes9313Zadb6rKqEoTpZpMbnWO9b/IbTxrh7G5K2lAuh1gpfFD",
	"NjRk21kDV+MUVh6ULDQu1lEjAGILta1K4gD6LME4sKx2H9hx4OlBSSIZ8lFVZE2LJ8cqa8cqa8cqa8cq",
	"a8cqa8dMpGOVtWOVtWOVtWOVtWOVtafLmspU+jpIzaJmQ6lQwzi2IsrUsaptyH7k3lHHA8utNFTTXqeq",
	"5Hmybld9f6YgVMcOIU9+1J/Qgtxo06wQObcuNbdXitzYoLCdlyyzuD/iccTng8Dnc8dZB5kzpGwPAa86",
	"kwg5KgR0jYBXY2fRnq2DjfOsERS5edziYQQpPq5wk63z5zsAAo+soK1AT+IjHZfMidxFhLzQd5qEgsDX",
	"EWUFVC8XZ0u5w7kjQ8L4HDPVg9CGAUMqTUmvTudKcUKRE+YqBQzRv7EoomyOxc/3BQGYSnX/OXqnKqB6",
	"Dz2DYrgoNPgRcnv+BP0jD7WOaMVVAlMJr8qoX0mza4b+XjhR8O9W3DkBxrzA02R0aGPLgNBHCB0+lmKu",
	"J1aoxJm8uNbDVWeLgt2ff8UY5b5JRvTnFdpn4pAg+N0PPO93IGme4Ce/q3MLW9VKLkSVFiQocN4Zn4Ia",
	"dLq97zinYyvTtQKNqu9pgpEs1JURGoBqiV2dwBq++MihutG8jxKyq+YqL8kVguw51OZKr3Uz0r1IBOTv",
	"XGJfrQYWrbmkLFgFMj7/8mDhBg+77XRqqdUh4BEy2seyYbllwyIIrUm818msCY/rqTNsImQ4ptqUp9qU",
	"IcVjke/G3loOLXWp11wL5CfEA+ozAMHSg9jn6I6DEGVlNgnEvpB4iO/dSyJ4S6gDxsaS+LOxAbCijOcf",
	"LwRhnCPo8fl9nkHyo9IcK26DmL4pF5LGgJhpiHlzNrpy7B+JVkaLmPdHafWRC7bnyP6aOPoL36WQcRrY",
	"PKBIE4a4ZG6RDKcC9OoJb6HhdveFA/IDPiY7NFHIbaqljexOp28NzFFraJndKeyb02HPNlF32nMhQoPW",
	"qJ2tJte22i2z1TbbgytreNYdnHUG/7CsM8sy4rLEg4dsqvuK3SNeRM0I72RkUARSIdqbHC+QUVokeTW0",
	"o0Y4dl3TTB2DySXyXFOtJyESf/fmk3sSUBCiQsK0pw4ueW9jjl7Nw9XnB5Ejq4/8FrKQdR9PPsO5Q6K7",
	"cvhPoHetqlKruLSZNpNH/WRMf1yutCpPYFeNxI5e5Z1gsVZKCAVBysJUiM+SmKEloaWFjT/JN5jxomrh",
	"2pCjWdbzFroxQlEqjBYW70BfyfNfwmL0gSoPoXJc14i9pwgyrcgVU4S10uoKQSWv5WPMVFJN5hZijX7Q",
	"ttEyrC3sBkz+BQNOKGLEuznsSsOHEAatLuKeTapqkl8w48dk5UozULqWuCKlspBaGA6Q8g7L00u2WMhh",
	"7uqlZ2ogzVyykMSWUlYNpRwCW0hZxelwiD2Wm1wbUb3ts5UVqd4B1axWxzY3DLceRcB6yp4R9FiiIC3h",
	"Kb9LRCtWKEws1zUVCrPmt/A2PlSLep/UNz/ev4mFpB2m6a+EzGXqknBO8TTguSaXWiRlA2EtIimfIiK6",
	"GoiVJAhlx/sLsaGH/0TOZZx0VbNWd46UUbMigHqQpPUKA77oNTfWyNOP7H5Kms/N/9dyeO5vIbKk12MT",
	"z0N2aBNfpbV1w4444dCrZ0M7GMHlSMLKRCagqVSBtFRpc7GTdKpICNqtcifdIAzxyGZcRFIvw3eeqNRJ",
	"co1ZC7D6RQWH3yKKwA30sMwoFTKsh/2vQvJAi6Wnqtes0ovwt5LB9Svg82eZ+1BJyFI5rXXM6sfwwFql",
	"29I30JflLUECO8ObFz0q11RSeL0LdaEYUc/B/3/54VegTldhqw19ME3iK5xB7DOuyuBCxhHjIMqGLcXh",
	"FL6tHKFMfG9b7bZpdcxW96rVOWuNzjqDJCaviZsPz4sSpCB7JAkvkiSsWI7r0YckD2wmD76KGV7FCLTV",
	"VUhvUlKJS/mj0JdDFAYssYkjVqzHKFRbYLBydzdnGKmz34xx5LKHNQ/+4Yh6leFtNU89lww0v2md92Ed",
	"gvAvrSfXkfpvone38rQeseCgCdCq1DC9j5uEOSUYySHHjGObNRNVfwoRMXo70bm6hr9TD72nli37j7xa",
	"SQ5TQFgrFIssFuLY1XhLDyOmm8+32g2DzymCjgBzd9DrD9pDRXu3yTmLl1gzUCuxwDJ0jXHgrTIGvgk/",
	"3FVRy3iGHEyPtwbglARct/HIKWiZGKYI15vfBIY9rIXynxVOVlNejbxPR3aPGPwMMbgmAisTXC28VSUg",
	"6xFqOeyRTB+RfE9IPgtxsTaOr0WiJaofCfQRd/eBu7EDBIQOkDpYrDwptdA3LNJVN4/hJRLqfntqW612",
	"z3RbU2h2O92OORw6HdOyYMdyB0PUn/YrkL2VRPZWu9PtPTQMVbaOGWedXjLDAN4gCmfIOOud9hrGFN4j",
	"hqFvnA1PuwPZwCwyj2vxL7pRYsw9XczkanMXO0gvtl+12Od40xNAyPWeR1DJBEaEMMqaHf4bex6YIuAH",
	"nnJ3YFfo1DqLIZGqR3wk7pl+LbxWegV+sJiqBcTgXzG1qSWAW4Rnc44cQHzZSi0uSbAkyyBOfEuPXIeg",
	"7ZbmvcO+U0T0snUDKyndWvxajn7k13skCw3DwUyFCunImpaMAG9Z8n9t+d+O/G9X/rcn/9uX/x0YZ+2G",
	"MZT/HRln1sORyOyIyMjL9ZRUZhUv0jts5QOkZeU/b+c/7uQ/7uY/7uU/7uc/HuQ/HuY/HtUMhcpzfRdh",
	"/Eb5ifuSTisJdSCbM5TRZdW+4RKxyGGwp+j59ETHRKXiGDBZTC+gFPlcuZrVKQIWHVJ43gqmqbNuTtFM",
	"JXTn+xt/FD9nD/3F1RzJ2eVmkeV7b35X61qkUOSSQyrDlNZHi+Y3bXDUqbk14gfD9/eTtSnP6ScH85eO",
	"i8k9blhG8iAw8ekym4RUpVnx31hYIpiBwNctRcIMjNbjre6zr6Jg8Z/IEcsLBLF2CGLAJxzM4Q0K7+gS",
	"0QWWgGWAUCkSCglRCHFMHC5yME8VUX3lI+QwXUs10C2WxKfSCgUWSEh0J0WUQQ4XDlWPPsiyHCZcLim5",
	"gZ5JE8H++VdXDfJGfHauv4oyBHYV+OgRGyrVK9Psa/Kt/fDKDP86eZ3b8CsywlVWg9lJEtJOWEW95rUx",
	"UjZWgx7lGbDwTHLL5tbqDbv7fgZ14h04cPOyewSaiSsGteSryh43gcIQWQ0ZKmFJXZwFcTSyghCnKy7A",
	"tyBJ/ypqV5xPoe8Q/9GE5zqd7OMS6mpxNeSDWgaYNFj2VL0hSCsi77CHDlcWWAQex0tIeVNs2Ayztoqo",
	"mIsVDYugM8U+lHb9Rw+JXkkwqy0QyBPJ8RogwSRZ7TElT61d610Pv2Xh46csZpmobCovI17AGZJ8XeZB",
	"ryPBrxCopqqyXVliR3doTJ7ks60qXNxtGfsX6rdWdYvJTdh723rq+sB5dXkgYEimi2kZMcIwl5KF3IpG",
	"vMsD4gKlSG2Thc6sPBDe9EYu6MWbTPK2eaA2k7jpYfU9UdvKobYA+o5u7nIf6UqSP65LhtNPBHmtVfks",
	"hywbh0Zd/AxdOWSy0qieQZ3NDogXKw+Z/qxyZPdWFMraa1GobBl+3XHmVaqniQWWiIbJ2ycFnVyws++u",
	"0OIk5J85bWK27Ygbjb3rSkj7LFIkjqush2haKBVnm6mkLnFXUzyGaFMRseY3mzgoz2icgy3qEyC+yG/p",
	"pn/ZUfn1JUW2rMCih1lNsBKrUiTtTTjzE1LZghq5ymKDQAzCDGHNHIx2YldHBYsPVUdIFSv5ssrV7aR+",
	"2GUU5qcgtN9CYpnZal9XmXVIZjPkKCRRGIAc8M9shK0+7kJ0iQqs18WZp6vNKgTOxG5VIrY+pcczT0ar",
	"cAhi/t943mryLZarB8YABP/MBJPGB1bRgC3GHTWGSvTaUzHzFOJIPlEPZXTHxudIZfba4jvqXLn9lU80",
	"Ts0w8JK7rzr91r/6T9sPNffmJ7p/Hsr1Ty5pHRqQ2920NiFIIMCjkYDKsPYE7qwR1/5diRoKLo/Q/Gl7",
	"GqN8cvXJi4oFdhFy1sGRdwg5O8CTJKL0nhhROIU+84RO8gv0ZwGcoSI1OOPXPjf/Zzw2J9/ajd7DD5tr",
	"xYTiGfah9zSzozt5TZwPT7oKfZFURe/M1BHaXBsMutJ4EMxmiHF8g6TTiXBsQ6HhR4sMDQBl7wullPpk",
	"RuFyju3cWorrQVDJ9Xs2oYSTaXsk3fd8moq+C3hAkWr4x/JPx2gJ4GrAW0bDaK1RBzsqZH2JfRtlJkjS",
	"w7eQoyu8QECNCG4xn2saKP7p6kpXv/3222/m+/fm27dXP/989v792eWl7G6MF+hP4iPw+erNPyxJxyJs",
	"Ho+db90H89oyW5Px2DFfXVtmW/z1V0c+O7l6Ff72V/vaMjuTk7Nry+yJB9EfPxi1txwVg/p+tqyDv76n",
	"LVeZLRMlPWpZLRsb1HxvxIBf4xuKoAOnHlrro1SFs5rf3BAv2IPddp9iYezTKp/lp8WS33+EM5TbU8Bq",
	"tCZry7OKEn+MDnRX4/50J64I9D5Tb2djfo7zMgp4hlWHZ0z2750sE7+/o06/KiavJNuhRPMQmgR4peEp",
	"9ZCTpCIi9IZCLWQNK8cTN5/KNXNoLfFALByhzrqGcSObmlTbrqEjux/LpFHHlavXvm+v7jO1aq7lcSy8",
	"8XmuyBJTg/zHGndc/HlgV1yi06HccLWYdS7453QPl9r3W8cT7Pl6zzHjuhtCcUcH2V7+Z/3mbksPxx0z",
	"C3o5xIlVeZ1ahKT8VleM3ayqb1mE7fYtMo+lGNMkTeAcA1RhFJhHKBXX7IfOe0i/pj34GY9a9rpiBm6x",
	"56mOAFLfsmXQ2pLiG8hR2n+QS/z27Yezvls/XLH7LXEqiaNeoCpG9X6vcSlihrUiAH9JbDbsKVUci7La",
	"r70qLEfHQD4pWy4Ke8ywNr3ZRunx7XcXdY+vILRIYG/RpqqZtaxEv09mLbBnLWIo+6NrilhNBS+cIx3c",
	"kg5W4NXfWF2C+KT4lt7JN+NHBKnQ/q4nAswM0Zv8VX2kxAnC9kwB9YwzY875kp01m3CJT6XBwUF3p4TO",
	"jNUA2o8KTx10gzyyXCCfA+TfYEp88Xf5iA66keGiGpbfQlCc27YsRyJmCx8t8RsPo8xD/jNZoNSTgM+R",
	"zzXCZH+RuVnRkzdwye05TD0KzZSJR+Qm8yAZohE9leaa5L+1wpB6RINF6smF71LIOA1sHtDUPn5BM2jf",
	"J5+EJpPogW7mm3wSi2Gpp6p5aPxkJRww8VNYSjv5LFG6JX6qA+GTT6SSNXn4fwEAAP//noBCw0oUAgA=",
}

// GetSwagger returns the content of the embedded swagger specification file
// or error if failed to decode
func decodeSpec() ([]byte, error) {
	zipped, err := base64.StdEncoding.DecodeString(strings.Join(swaggerSpec, ""))
	if err != nil {
		return nil, fmt.Errorf("error base64 decoding spec: %w", err)
	}
	zr, err := gzip.NewReader(bytes.NewReader(zipped))
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}
	var buf bytes.Buffer
	_, err = buf.ReadFrom(zr)
	if err != nil {
		return nil, fmt.Errorf("error decompressing spec: %w", err)
	}

	return buf.Bytes(), nil
}

var rawSpec = decodeSpecCached()

// a naive cached of a decoded swagger spec
func decodeSpecCached() func() ([]byte, error) {
	data, err := decodeSpec()
	return func() ([]byte, error) {
		return data, err
	}
}

// Constructs a synthetic filesystem for resolving external references when loading openapi specifications.
func PathToRawSpec(pathToFile string) map[string]func() ([]byte, error) {
	res := make(map[string]func() ([]byte, error))
	if len(pathToFile) > 0 {
		res[pathToFile] = rawSpec
	}

	return res
}

// GetSwagger returns the Swagger specification corresponding to the generated code
// in this file. The external references of Swagger specification are resolved.
// The logic of resolving external references is tightly connected to "import-mapping" feature.
// Externally referenced files must be embedded in the corresponding golang packages.
// Urls can be supported but this task was out of the scope.
func GetSwagger() (swagger *openapi3.T, err error) {
	resolvePath := PathToRawSpec("")

	loader := openapi3.NewLoader()
	loader.IsExternalRefsAllowed = true
	loader.ReadFromURIFunc = func(loader *openapi3.Loader, url *url.URL) ([]byte, error) {
		pathToFile := url.String()
		pathToFile = path.Clean(pathToFile)
		getSpec, ok := resolvePath[pathToFile]
		if !ok {
			err1 := fmt.Errorf("path not found: %s", pathToFile)
			return nil, err1
		}
		return getSpec()
	}
	var specData []byte
	specData, err = rawSpec()
	if err != nil {
		return
	}
	swagger, err = loader.LoadFromData(specData)
	if err != nil {
		return
	}
	return
}
